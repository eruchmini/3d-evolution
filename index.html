<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bird Flying Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }

        #instructions h2 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        #instructions ul {
            list-style-position: inside;
            margin-left: 10px;
        }

        #instructions li {
            margin: 5px 0;
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            min-width: 200px;
        }

        #stats div {
            margin: 5px 0;
        }

        .speed-indicator {
            font-weight: bold;
        }

        .high-speed {
            color: #ff4444;
        }

        .low-speed {
            color: #44ff44;
        }

        #oxygenBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 3px;
            display: none;
        }

        #oxygenFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0099ff);
            border-radius: 12px;
            transition: width 0.3s ease;
        }

        #underwaterOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(0, 80, 120, 0.3) 0%, rgba(0, 40, 80, 0.6) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #hungerBar {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff9900;
            border-radius: 15px;
            padding: 3px;
        }

        #hungerFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff9900);
            border-radius: 12px;
            transition: width 0.3s ease;
        }

        #upgradeMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #00ffff;
            display: none;
            z-index: 1000;
            min-width: 500px;
            max-width: 600px;
        }

        #upgradeMenu h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #00ffff;
            font-size: 28px;
        }

        #upgradeMenu .points-display {
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            color: #ffff00;
        }

        #upgradeMenu .upgrade-option {
            background: rgba(0, 100, 150, 0.3);
            border: 2px solid #0099ff;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #upgradeMenu .upgrade-option:hover {
            background: rgba(0, 150, 200, 0.5);
            border-color: #00ffff;
            transform: scale(1.02);
        }

        #upgradeMenu .upgrade-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #upgradeMenu .upgrade-option.disabled:hover {
            transform: none;
            background: rgba(0, 100, 150, 0.3);
            border-color: #0099ff;
        }

        #upgradeMenu .upgrade-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #00ffff;
        }

        #upgradeMenu .upgrade-cost {
            font-size: 14px;
            color: #ffff00;
            margin-bottom: 8px;
        }

        #upgradeMenu .upgrade-description {
            font-size: 14px;
            color: #ffffff;
            line-height: 1.4;
        }

        #upgradeMenu .save-button {
            background: rgba(100, 100, 100, 0.5);
            border: 2px solid #888888;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        #upgradeMenu .save-button:hover {
            background: rgba(150, 150, 150, 0.5);
            border-color: #aaaaaa;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>üó°Ô∏è Swordfish Hunter</h2>
        <ul>
            <li><strong>W/‚Üë</strong> - Pitch up</li>
            <li><strong>S/‚Üì</strong> - Pitch down</li>
            <li><strong>A/‚Üê</strong> - Turn left</li>
            <li><strong>D/‚Üí</strong> - Turn right</li>
            <li><strong>Space</strong> - Speed boost</li>
            <li><strong>F</strong> - Toggle 1st/3rd person view</li>
        </ul>
        <p style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
            You're a swordfish! Hunt fish in schools, avoid sharks, and jump out of water for short bursts!
        </p>
    </div>

    <div id="stats">
        <div>Altitude: <span id="altitude">0</span>m</div>
        <div>Speed: <span id="speed" class="speed-indicator">0</span></div>
        <div>Pitch: <span id="pitch">0</span>¬∞</div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Fish Caught: <span id="caughtFish">0</span></div>
        <div>Hunger: <span id="hunger">100</span>%</div>
    </div>

    <div id="oxygenBar">
        <div id="oxygenFill"></div>
    </div>

    <div id="hungerBar">
        <div id="hungerFill"></div>
    </div>

    <div id="underwaterOverlay"></div>

    <div id="upgradeMenu">
        <h2>‚ö° UPGRADE AVAILABLE! ‚ö°</h2>
        <div class="points-display">Upgrade Points: <span id="upgradePoints">0</span></div>
        <div id="upgradeOptions"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Ocean sky with gradient
        const skyColor = 0x5BA3D0; // Ocean blue sky
        const horizonColor = 0xffffff;
        scene.background = new THREE.Color(skyColor);
        scene.fog = new THREE.FogExp2(0x5BA3D0, 0.001);

        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xfff5e1, 1.2);
        directionalLight.position.set(100, 150, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // Add hemisphere light for better ambient lighting
        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.5);
        scene.add(hemisphereLight);

        // Create swordfish (player)
        const bird = new THREE.Group();

        // Swordfish body (streamlined)
        const bodyGeometry = new THREE.SphereGeometry(0.4, 32, 32);
        bodyGeometry.scale(1, 0.9, 2.5);
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x1E40AF, // Deep blue
            metalness: 0.6,
            roughness: 0.3,
            emissive: 0x0000FF,
            emissiveIntensity: 0.1
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        bird.add(body);

        // Swordfish underbelly (lighter)
        const bellyGeometry = new THREE.SphereGeometry(0.35, 32, 32);
        bellyGeometry.scale(1, 0.7, 2.2);
        const bellyMaterial = new THREE.MeshStandardMaterial({
            color: 0xE0E7FF, // Light blue
            metalness: 0.5,
            roughness: 0.4
        });
        const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
        belly.position.y = -0.2;
        bird.add(belly);

        // Sword/Bill (long pointed nose)
        const swordGeometry = new THREE.ConeGeometry(0.08, 1.5, 8);
        const swordMaterial = new THREE.MeshStandardMaterial({
            color: 0x6B7280,
            metalness: 0.8,
            roughness: 0.2
        });
        const sword = new THREE.Mesh(swordGeometry, swordMaterial);
        sword.position.set(0, 0, 1.5);
        sword.rotation.x = Math.PI / 2;
        sword.castShadow = true;
        bird.add(sword);

        // Swordfish eyes
        const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.25, 0.2, 0.7);
        bird.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.25, 0.2, 0.7);
        bird.add(rightEye);

        // Eye pupils
        const pupilGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        leftPupil.position.set(-0.25, 0.2, 0.75);
        bird.add(leftPupil);
        const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        rightPupil.position.set(0.25, 0.2, 0.75);
        bird.add(rightPupil);

        // Dorsal fin
        const dorsalFinGeometry = new THREE.ConeGeometry(0.25, 0.8, 8);
        const finMaterial = new THREE.MeshStandardMaterial({
            color: 0x1E40AF,
            metalness: 0.5,
            roughness: 0.4
        });
        const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
        dorsalFin.position.set(0, 0.6, -0.3);
        dorsalFin.rotation.x = Math.PI;
        dorsalFin.castShadow = true;
        bird.add(dorsalFin);

        // Pectoral fins (side fins)
        const pectoralFinGeometry = new THREE.ConeGeometry(0.2, 0.6, 8);
        const leftWing = new THREE.Mesh(pectoralFinGeometry, finMaterial);
        leftWing.position.set(-0.4, 0, 0.2);
        leftWing.rotation.z = Math.PI / 2.5;
        leftWing.castShadow = true;
        bird.add(leftWing);

        const rightWing = new THREE.Mesh(pectoralFinGeometry, finMaterial);
        rightWing.position.set(0.4, 0, 0.2);
        rightWing.rotation.z = -Math.PI / 2.5;
        rightWing.castShadow = true;
        bird.add(rightWing);

        // Tail fin (crescent shaped)
        const tailGeometry = new THREE.ConeGeometry(0.45, 1.0, 8);
        const tail = new THREE.Mesh(tailGeometry, finMaterial);
        tail.position.set(0, 0, -1.2);
        tail.rotation.x = Math.PI / 2;
        tail.castShadow = true;
        bird.add(tail);

        bird.position.set(0, -5, 0); // Start underwater
        scene.add(bird);

        // Motion trail
        const trailPoints = [];
        const trailLength = 20;
        for (let i = 0; i < trailLength; i++) {
            trailPoints.push(new THREE.Vector3(0, -5, 0));
        }
        const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
        const trailMaterial = new THREE.LineBasicMaterial({
            color: 0x1E40AF, // Blue swordfish trail
            transparent: true,
            opacity: 0.4,
            linewidth: 2
        });
        const trail = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trail);

        // Ocean surface with animated waves
        const oceanGeometry = new THREE.PlaneGeometry(2000, 2000, 150, 150);
        const oceanMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            roughness: 0.4,
            metalness: 0.6,
            transparent: true,
            opacity: 0.9
        });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.y = 0;
        ocean.receiveShadow = true;

        // Store original positions for wave animation
        const oceanPositions = ocean.geometry.attributes.position;
        const originalPositions = new Float32Array(oceanPositions.count * 3);
        const waveRandomness = new Float32Array(oceanPositions.count); // Random amplitude for each vertex
        for (let i = 0; i < oceanPositions.count; i++) {
            originalPositions[i * 3] = oceanPositions.getX(i);
            originalPositions[i * 3 + 1] = oceanPositions.getY(i);
            originalPositions[i * 3 + 2] = oceanPositions.getZ(i);
            waveRandomness[i] = 0.5 + Math.random() * 1.5; // Random multiplier between 0.5 and 2.0
        }

        scene.add(ocean);

        // Ocean floor
        const oceanFloorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        const oceanFloorMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B7355, // Sandy brown
            roughness: 0.95,
            metalness: 0.05
        });
        const oceanFloor = new THREE.Mesh(oceanFloorGeometry, oceanFloorMaterial);
        oceanFloor.rotation.x = -Math.PI / 2;
        oceanFloor.position.y = -80; // Ocean floor at -80m (DEEP ocean)
        oceanFloor.receiveShadow = true;

        // Add variation to ocean floor for terrain effect
        const floorPositions = oceanFloor.geometry.attributes.position;
        for (let i = 0; i < floorPositions.count; i++) {
            const variation = Math.random() * 0.5 + Math.sin(i * 0.1) * 0.3;
            floorPositions.setZ(i, variation);
        }
        floorPositions.needsUpdate = true;
        oceanFloor.geometry.computeVertexNormals();

        scene.add(oceanFloor);

        // Create enhanced clouds
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.7,
                roughness: 1,
                metalness: 0
            });

            for (let i = 0; i < 7; i++) {
                const cloudPart = new THREE.Mesh(
                    new THREE.SphereGeometry(Math.random() * 2.5 + 1.5, 16, 16),
                    cloudMaterial
                );
                cloudPart.position.set(
                    Math.random() * 5 - 2.5,
                    Math.random() * 2 - 1,
                    Math.random() * 5 - 2.5
                );
                cloud.add(cloudPart);
            }

            cloud.position.set(x, y, z);
            return cloud;
        }

        // Add multiple clouds at various heights
        const clouds = [];
        for (let i = 0; i < 30; i++) {
            const cloud = createCloud(
                Math.random() * 300 - 150,
                Math.random() * 40 + 20,
                Math.random() * 300 - 150
            );
            clouds.push(cloud);
            scene.add(cloud);
        }

        // Trees removed - now ocean environment

        // Grass removed - ocean environment

        // Mountains removed - open ocean environment
        const MAP_SIZE = 500; // Larger ocean area

        // Create fish
        function createFish(x, z) {
            const fish = new THREE.Group();

            // Fish colors - variety of ocean fish
            const fishColors = [
                0xFF6B35, // Orange
                0xFFD23F, // Yellow
                0x00A6ED, // Blue
                0xFF006E, // Pink
                0x3BCEAC, // Teal
                0xA463F2, // Purple
            ];
            const fishColor = fishColors[Math.floor(Math.random() * fishColors.length)];

            // Fish body (elongated sphere)
            const bodyGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            bodyGeometry.scale(1, 0.9, 1.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: fishColor,
                roughness: 0.4,
                metalness: 0.5,
                emissive: fishColor,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            fish.add(body);

            // Fish eyes
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeWhiteMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
            leftEye.position.set(-0.15, 0.12, 0.35);
            fish.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
            rightEye.position.set(0.15, 0.12, 0.35);
            fish.add(rightEye);

            // Eye pupils
            const pupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.15, 0.12, 0.41);
            fish.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.15, 0.12, 0.41);
            fish.add(rightPupil);

            // Dorsal fin (top fin)
            const dorsalFinGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const finMaterial = new THREE.MeshStandardMaterial({
                color: fishColor,
                roughness: 0.5,
                metalness: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
            dorsalFin.position.set(0, 0.35, 0);
            dorsalFin.rotation.x = Math.PI;
            fish.add(dorsalFin);

            // Side fins
            const sideFinsGeometry = new THREE.ConeGeometry(0.12, 0.3, 8);
            const leftFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            leftFin.position.set(-0.25, -0.05, 0.1);
            leftFin.rotation.z = Math.PI / 3;
            fish.add(leftFin);
            const rightFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            rightFin.position.set(0.25, -0.05, 0.1);
            rightFin.rotation.z = -Math.PI / 3;
            fish.add(rightFin);

            // Tail fin
            const tailGeometry = new THREE.ConeGeometry(0.25, 0.5, 8);
            const tail = new THREE.Mesh(tailGeometry, finMaterial);
            tail.position.set(0, 0, -0.5);
            tail.rotation.x = -Math.PI / 2;
            fish.add(tail);

            // Start fish at various depths in deep ocean
            const depth = -2 - Math.random() * 60; // Between -2 and -62 meters
            fish.position.set(x, depth, z);

            // Add custom properties for behavior (boid/flocking)
            fish.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,
                (Math.random() - 0.5) * 0.08,
                (Math.random() - 0.5) * 0.15
            );
            fish.userData.swimSpeed = 0.18; // Even slower swimming fish
            fish.userData.maxSpeed = 0.24; // Further reduced max speed
            fish.userData.isCaught = false;
            fish.userData.swimTime = Math.random() * 100;
            fish.userData.radius = 0.5; // Collision radius for hitbox

            return fish;
        }

        // Spawn fish across the ocean - HUGE MASSIVE PACKS!
        const fish = [];
        const NUM_FISH = 1500; // MASSIVE schools of fish!

        // Spawn fish in large clusters for big pack behavior
        const NUM_CLUSTERS = 20; // Number of major fish schools
        for (let cluster = 0; cluster < NUM_CLUSTERS; cluster++) {
            // Each cluster has a center point
            const clusterAngle = Math.random() * Math.PI * 2;
            const clusterDistance = Math.random() * 400;
            const clusterX = Math.cos(clusterAngle) * clusterDistance;
            const clusterZ = Math.sin(clusterAngle) * clusterDistance;

            // Spawn many fish around this cluster center
            const fishPerCluster = Math.floor(NUM_FISH / NUM_CLUSTERS);
            for (let i = 0; i < fishPerCluster; i++) {
                // Fish spawn close to cluster center
                const offsetAngle = Math.random() * Math.PI * 2;
                const offsetDistance = Math.random() * 30; // Cluster radius
                const newFish = createFish(
                    clusterX + Math.cos(offsetAngle) * offsetDistance,
                    clusterZ + Math.sin(offsetAngle) * offsetDistance
                );
                fish.push(newFish);
                scene.add(newFish);
            }
        }

        let caughtFishCount = 0;

        // Create sharks
        function createShark(x, z) {
            const shark = new THREE.Group();

            // Shark body (elongated and larger)
            const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            bodyGeometry.scale(1, 0.8, 2.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568, // Dark gray
                roughness: 0.6,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            shark.add(body);

            // Shark underbelly (lighter)
            const bellyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            bellyGeometry.scale(1, 0.6, 2.2);
            const bellyMaterial = new THREE.MeshStandardMaterial({
                color: 0xE5E7EB, // Light gray
                roughness: 0.6,
                metalness: 0.2
            });
            const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
            belly.position.y = -0.2;
            shark.add(belly);

            // Shark head/snout
            const snoutGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const snoutMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568,
                roughness: 0.6,
                metalness: 0.3
            });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0, 0, 1.5);
            snout.rotation.x = Math.PI / 2;
            shark.add(snout);

            // Shark eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.25, 0.2, 1.1);
            shark.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.25, 0.2, 1.1);
            shark.add(rightEye);

            // Dorsal fin (top)
            const dorsalFinGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568,
                roughness: 0.6,
                metalness: 0.3
            });
            const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
            dorsalFin.position.set(0, 0.6, -0.2);
            dorsalFin.rotation.x = Math.PI;
            shark.add(dorsalFin);

            // Side fins
            const sideFinsGeometry = new THREE.ConeGeometry(0.25, 0.6, 8);
            const leftFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            leftFin.position.set(-0.5, -0.1, 0.3);
            leftFin.rotation.z = Math.PI / 2.5;
            shark.add(leftFin);
            const rightFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            rightFin.position.set(0.5, -0.1, 0.3);
            rightFin.rotation.z = -Math.PI / 2.5;
            shark.add(rightFin);

            // Tail fin
            const tailGeometry = new THREE.ConeGeometry(0.4, 1.0, 8);
            const tail = new THREE.Mesh(tailGeometry, finMaterial);
            tail.position.set(0, 0.2, -1.5);
            tail.rotation.x = -Math.PI / 2;
            shark.add(tail);

            shark.position.set(x, -20, z); // Patrol at mid-depth in deep ocean

            // Add custom properties for behavior
            shark.userData.velocity = new THREE.Vector3(0, 0, 0);
            shark.userData.swimSpeed = 0.55; // Slightly faster than player for chase tension
            shark.userData.patrolAngle = Math.random() * Math.PI * 2;
            shark.userData.verticalAngle = 0;
            shark.userData.swimTime = Math.random() * 100;
            shark.userData.isShark = true;

            return shark;
        }

        // Spawn many sharks
        const sharks = [];
        const NUM_SHARKS = 15; // Lots of sharks!
        for (let i = 0; i < NUM_SHARKS; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 350 + 50;
            const newShark = createShark(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            // Vary shark starting depths in deep ocean
            newShark.position.y = -10 - Math.random() * 50; // Between -10 and -60
            sharks.push(newShark);
            scene.add(newShark);
        }

        // Camera setup
        camera.position.set(0, -3, -10);
        camera.lookAt(bird.position);

        // Game state with momentum system
        const keys = {};
        let birdYaw = 0; // Horizontal rotation (left/right)
        let birdPitch = 0; // Vertical rotation (up/down)
        let forwardSpeed = 0.3; // Current forward speed
        const minSpeed = 0.15;
        const maxSpeed = 0.8;
        const cruisingSpeed = 0.3; // Natural cruising speed when flying level
        const pitchSpeed = 0.025; // How fast pitch changes
        const yawSpeed = 0.03; // How fast yaw changes
        const pitchDecay = 0.92; // How quickly pitch returns to neutral
        let wingFlap = 0;
        let trailIndex = 0;
        let bankingAngle = 0; // Current tilt angle when turning
        let isFirstPerson = true; // Camera mode: true = first-person, false = third-person
        let previousPosition = new THREE.Vector3(0, -5, 0); // Track previous position for velocity calculation

        // Underwater / jumping mechanics
        let isUnderwater = false;
        let airTime = 100; // Air time when above water (0-100)
        const maxAirTime = 100;
        const airTimeDepletionRate = 0.5; // Per frame when above water
        const airTimeRecoveryRate = 2.0; // Per frame when underwater (quick recovery)
        let waveTime = 0; // For wave animation
        let timeAboveWater = 0; // Track how long we've been above water
        const GRAVITY_GRACE_PERIOD = 1.5; // Seconds before gravity kicks in

        // Hunger system
        let hunger = 100; // Hunger level (0-100)
        const maxHunger = 100;
        const hungerDepletionRate = 0.05; // Passive hunger loss per frame
        const boostHungerCost = 0.8; // Hunger cost per frame when boosting
        const fishHungerGain = 15; // Hunger gained from eating a fish
        let hasReachedMaxHunger = false; // Track if we've reached max hunger for upgrade point

        // Upgrade system
        let upgradePoints = 0;
        let isPaused = false;
        const activeUpgrades = {}; // Track which upgrades are active

        // All available upgrades
        const allUpgrades = [
            // FREE UPGRADES
            { id: 'vision', name: 'üëÅÔ∏è Enhanced Vision', cost: 0, description: 'See sharks and fish from further away with glowing outlines' },
            { id: 'compass', name: 'üß≠ Compass Sense', cost: 0, description: 'Always know which direction is north' },
            { id: 'depth_gauge', name: 'üìä Depth Gauge', cost: 0, description: 'See exact depth with visual indicators' },

            // 1 POINT UPGRADES - BASIC
            { id: 'speed', name: '‚ö° Speed Boost', cost: 1, description: 'Permanently increase your swimming speed by 20%' },
            { id: 'hunger_slow', name: 'üçΩÔ∏è Efficient Metabolism', cost: 1, description: 'Hunger depletes 30% slower' },
            { id: 'fish_value', name: 'üêü Nutritious Fish', cost: 1, description: 'Each fish restores 25% more hunger' },
            { id: 'boost_efficient', name: 'üí® Efficient Boost', cost: 1, description: 'Speed boost costs 50% less hunger' },
            { id: 'air_time', name: 'üåä Improved Lungs', cost: 1, description: 'Jump out of water for 50% longer' },
            { id: 'turning', name: 'üîÑ Agile Turns', cost: 1, description: 'Turn 30% faster for better maneuverability' },
            { id: 'acceleration', name: 'üöÄ Quick Acceleration', cost: 1, description: 'Reach top speed 40% faster' },
            { id: 'fish_magnet', name: 'üß≤ Fish Attraction', cost: 1, description: 'Fish spawn closer to you' },
            { id: 'stealth', name: 'üëª Stealth Mode', cost: 1, description: 'Sharks take 30% longer to notice you' },
            { id: 'lucky', name: 'üçÄ Lucky Catch', cost: 1, description: '10% chance to catch 2 fish at once' },

            // 1 POINT UPGRADES - ADVANCED
            { id: 'radar', name: 'üì° Fish Radar', cost: 1, description: 'See nearby fish through walls with sonar pulses' },
            { id: 'regeneration', name: 'üíö Slow Regeneration', cost: 1, description: 'Slowly regenerate hunger over time when above 50%' },
            { id: 'grace_period', name: 'üïäÔ∏è Extended Grace', cost: 1, description: 'Jump grace period lasts 2x longer before gravity kicks in' },
            { id: 'deep_diver', name: 'üèä Deep Diver', cost: 1, description: 'Swim 20% faster below -40m depth' },
            { id: 'surface_swimmer', name: 'üèÑ Surface Swimmer', cost: 1, description: 'Swim 20% faster near the surface (above -10m)' },

            // 2 POINT UPGRADES - POWERFUL
            { id: 'mega_speed', name: '‚ö°‚ö° Mega Speed', cost: 2, description: 'Permanently increase speed by 50% (very fast!)' },
            { id: 'shark_repel', name: 'ü¶à Shark Repellent', cost: 2, description: 'Sharks are afraid of you and keep their distance' },
            { id: 'infinite_air', name: 'ü´Å Enhanced Gills', cost: 2, description: 'Never run out of air when jumping' },
            { id: 'double_catch', name: 'üêüüêü Double Catch', cost: 2, description: 'Always catch 2 fish at once' },
            { id: 'no_hunger', name: '‚ôæÔ∏è Endless Energy', cost: 2, description: 'Hunger depletes 80% slower' },
            { id: 'mega_boost', name: 'üí®üí® Mega Boost', cost: 2, description: 'Speed boost is 2x more powerful' },
            { id: 'time_slow', name: '‚è∞ Bullet Time', cost: 2, description: 'Hold SHIFT to slow down time for precise maneuvers' },
            { id: 'invincible_jump', name: 'üõ°Ô∏è Invincible Jump', cost: 2, description: 'Sharks cannot attack you while above water' },
            { id: 'fish_swarm', name: 'üê† Fish Swarm Master', cost: 2, description: 'Fish schools are 50% larger and denser' },
            { id: 'predator_sense', name: '‚ö†Ô∏è Predator Sense', cost: 2, description: 'Screen flashes red when a shark is chasing you' },
            { id: 'ultra_agility', name: 'üåÄ Ultra Agility', cost: 2, description: 'Turn and pitch 50% faster with tighter controls' },
            { id: 'hunting_frenzy', name: 'üòà Hunting Frenzy', cost: 2, description: 'Each fish caught increases speed for 10 seconds (stacks)' },
            { id: 'depth_master', name: 'üåä Depth Master', cost: 2, description: 'Swim 40% faster at extreme depths (below -60m)' },
            { id: 'ghost_mode', name: 'üëª Ghost Mode', cost: 2, description: 'Become nearly invisible to sharks (80% detection reduction)' },
        ];

        // Shark respawning
        let sharkSpawnTimer = 0;
        const sharkSpawnInterval = 600; // Spawn a new shark every ~10 seconds (at 60fps)

        // Fish AI optimization - staggered updates
        let fishUpdateOffset = 0; // Which group of fish to update this frame
        const FISH_UPDATE_BATCH_SIZE = 150; // Update 150 fish per frame (10% of 1500)

        // Mouse look controls
        let isMouseLooking = false;
        let mouseLookYawOffset = 0; // Horizontal camera rotation offset from mouse
        let mouseStartX = 0;
        const mouseSensitivity = 0.008; // How much mouse movement affects camera (higher = more sensitive)

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;

            // Toggle camera mode with F key
            if (e.key === 'f' || e.key === 'F') {
                isFirstPerson = !isFirstPerson;
                console.log('Camera mode:', isFirstPerson ? 'First Person' : 'Third Person');
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        // Mouse look controls - hold left or right click to look around
        window.addEventListener('mousedown', (e) => {
            // Left click (0) or right click (2)
            if (e.button === 0 || e.button === 2) {
                isMouseLooking = true;
                mouseStartX = e.clientX;
                e.preventDefault(); // Prevent context menu on right click
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0 || e.button === 2) {
                isMouseLooking = false;
                // Smoothly return camera to center
                mouseLookYawOffset *= 0.9;
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isMouseLooking) {
                const deltaX = e.clientX - mouseStartX;
                mouseLookYawOffset = deltaX * mouseSensitivity;
                // Limit how far you can look around (approximately 180 degrees left/right)
                mouseLookYawOffset = Math.max(-Math.PI, Math.min(Math.PI, mouseLookYawOffset));
            }
        });

        // Prevent context menu on right click
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Upgrade system functions
        function showUpgradeMenu() {
            isPaused = true;

            // Filter out already owned upgrades
            const availableUpgrades = allUpgrades.filter(u => !activeUpgrades[u.id]);

            // Randomly select 2 upgrades
            const shuffled = availableUpgrades.sort(() => Math.random() - 0.5);
            const selectedUpgrades = shuffled.slice(0, 2);

            // Display upgrade menu
            const menu = document.getElementById('upgradeMenu');
            const optionsDiv = document.getElementById('upgradeOptions');
            const pointsSpan = document.getElementById('upgradePoints');

            pointsSpan.textContent = upgradePoints;
            optionsDiv.innerHTML = '';

            // Add upgrade options
            selectedUpgrades.forEach(upgrade => {
                const canAfford = upgradePoints >= upgrade.cost;
                const optionDiv = document.createElement('div');
                optionDiv.className = 'upgrade-option' + (canAfford ? '' : ' disabled');
                optionDiv.innerHTML = `
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-cost">${upgrade.cost === 0 ? 'FREE' : `Cost: ${upgrade.cost} point${upgrade.cost > 1 ? 's' : ''}`}</div>
                    <div class="upgrade-description">${upgrade.description}</div>
                `;

                if (canAfford) {
                    optionDiv.onclick = () => selectUpgrade(upgrade);
                }

                optionsDiv.appendChild(optionDiv);
            });

            // Add "Save for Later" button
            const saveButton = document.createElement('div');
            saveButton.className = 'save-button';
            saveButton.innerHTML = '<strong>üíæ Save for Later</strong><br>Keep your upgrade point for future use';
            saveButton.onclick = () => {
                menu.style.display = 'none';
                isPaused = false;
            };
            optionsDiv.appendChild(saveButton);

            menu.style.display = 'block';
        }

        function selectUpgrade(upgrade) {
            if (upgradePoints >= upgrade.cost) {
                upgradePoints -= upgrade.cost;
                activeUpgrades[upgrade.id] = true;
                console.log('Upgrade acquired:', upgrade.name);

                // Apply upgrade effects
                applyUpgrade(upgrade.id);

                // Close menu
                document.getElementById('upgradeMenu').style.display = 'none';
                isPaused = false;
            }
        }

        function applyUpgrade(upgradeId) {
            // Most upgrades are passive and checked during gameplay
            // Some upgrades need immediate application
            switch(upgradeId) {
                case 'mega_speed':
                case 'speed':
                    // Speed increases are applied in real-time during movement
                    break;
                case 'fish_swarm':
                    // Spawn more fish
                    for (let i = 0; i < 300; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 200 + 50;
                        const newFish = createFish(
                            Math.cos(angle) * distance,
                            Math.sin(angle) * distance
                        );
                        fish.push(newFish);
                        scene.add(newFish);
                    }
                    break;
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop with momentum-based physics
        function animate() {
            requestAnimationFrame(animate);

            // Skip game logic if paused (upgrade menu)
            if (isPaused) {
                renderer.render(scene, camera);
                return;
            }

            // Check if hunger reached max for upgrade point
            if (hunger >= maxHunger && !hasReachedMaxHunger) {
                hasReachedMaxHunger = true;
                upgradePoints++;
                console.log('Max hunger reached! Earned 1 upgrade point. Total:', upgradePoints);
                showUpgradeMenu();
            }

            // Reset flag when hunger drops below max
            if (hunger < maxHunger) {
                hasReachedMaxHunger = false;
            }

            // Animate ocean waves - RANDOM SIZE WAVES!
            waveTime += 0.02;
            for (let i = 0; i < oceanPositions.count; i++) {
                const x = originalPositions[i * 3];
                const y = originalPositions[i * 3 + 1];
                const z = originalPositions[i * 3 + 2];

                // Create wave pattern with random amplitudes for varied wave sizes
                const randomAmp = waveRandomness[i];
                const wave1 = Math.sin(x * 0.05 + waveTime) * 2.5 * randomAmp;
                const wave2 = Math.sin(z * 0.03 + waveTime * 1.3) * 2.0 * randomAmp;
                const wave3 = Math.sin((x + z) * 0.02 + waveTime * 0.8) * 1.5 * randomAmp;

                oceanPositions.setZ(i, wave1 + wave2 + wave3);
            }
            oceanPositions.needsUpdate = true;
            ocean.geometry.computeVertexNormals();

            // Check if underwater
            const wasUnderwater = isUnderwater;
            isUnderwater = bird.position.y < 0;

            // Track time above water for gravity grace period
            if (!isUnderwater) {
                if (wasUnderwater) {
                    // Just breached the surface - reset timer
                    timeAboveWater = 0;
                } else {
                    // Still above water - increment timer (60 fps = ~0.0167s per frame)
                    timeAboveWater += 1/60;
                }
            } else {
                timeAboveWater = 0; // Reset when underwater
            }

            // Air time system (for jumping out of water) with upgrades
            if (!isUnderwater) {
                // Above water - deplete air time (unless infinite air upgrade)
                if (!activeUpgrades['infinite_air']) {
                    let effectiveAirDepletion = airTimeDepletionRate;
                    if (activeUpgrades['air_time']) effectiveAirDepletion *= 0.5; // 50% slower depletion
                    airTime = Math.max(0, airTime - effectiveAirDepletion);
                    document.getElementById('oxygenBar').style.display = 'block';

                    // Force back underwater if air time runs out
                    if (airTime <= 0) {
                        bird.position.y = -0.5; // Force underwater
                        airTime = 0;
                    }
                } else {
                    // Infinite air - keep it full
                    airTime = maxAirTime;
                    document.getElementById('oxygenBar').style.display = 'none';
                }
            } else {
                // Underwater - recover air time
                airTime = Math.min(maxAirTime, airTime + airTimeRecoveryRate);
                if (airTime >= maxAirTime) {
                    document.getElementById('oxygenBar').style.display = 'none';
                }
            }

            // Update air time bar
            document.getElementById('oxygenFill').style.width = airTime + '%';

            // Hunger system - passive depletion with upgrades
            let effectiveHungerDepletion = hungerDepletionRate;
            if (activeUpgrades['hunger_slow']) effectiveHungerDepletion *= 0.7; // 30% slower
            if (activeUpgrades['no_hunger']) effectiveHungerDepletion *= 0.2; // 80% slower
            hunger = Math.max(0, hunger - effectiveHungerDepletion);

            // Regeneration upgrade
            if (activeUpgrades['regeneration'] && hunger > 50 && hunger < maxHunger) {
                hunger = Math.min(maxHunger, hunger + 0.02); // Slow regen
            }

            // Hunger cost from boosting with upgrades
            if (keys[' '] || keys['Space']) {
                let effectiveBoostCost = boostHungerCost;
                if (activeUpgrades['boost_efficient']) effectiveBoostCost *= 0.5; // 50% cheaper
                hunger = Math.max(0, hunger - effectiveBoostCost);
            }

            // Update hunger bar
            document.getElementById('hungerFill').style.width = hunger + '%';

            // Death from starvation
            if (hunger <= 0) {
                bird.position.set(0, -5, 0);
                birdPitch = 0;
                birdYaw = 0;
                hunger = maxHunger;
                airTime = maxAirTime;
                const fishLost = Math.floor(caughtFishCount / 2);
                caughtFishCount -= fishLost;
                console.log("Starved! Lost " + fishLost + " fish!");
            }

            // Update underwater overlay and fog
            const overlay = document.getElementById('underwaterOverlay');
            if (isUnderwater) {
                overlay.style.opacity = '0.3'; // Less dark overlay
                // Better underwater visibility!
                scene.fog.density = 0.015; // Much less fog - can see further
                scene.fog.color.setHex(0x004466); // Dark blue underwater fog
                scene.background.setHex(0x005577); // Lighter underwater background
            } else {
                overlay.style.opacity = '0';
                // Clear fog above water
                scene.fog.density = 0.001;
                scene.fog.color.setHex(0x5BA3D0); // Ocean blue sky
                scene.background.setHex(0x5BA3D0);
            }

            // Pitch controls (W = up, S = down) with upgrades
            let effectivePitchSpeed = pitchSpeed;
            if (activeUpgrades['ultra_agility']) effectivePitchSpeed *= 1.5; // 50% faster

            if (keys['w'] || keys['ArrowUp']) {
                birdPitch += effectivePitchSpeed;
            }
            if (keys['s'] || keys['ArrowDown']) {
                birdPitch -= effectivePitchSpeed;
            }

            // Apply pitch decay when no input (returns to level flight)
            if (!keys['w'] && !keys['ArrowUp'] && !keys['s'] && !keys['ArrowDown']) {
                birdPitch *= pitchDecay;
            }

            // Limit pitch angle
            birdPitch = Math.max(-0.8, Math.min(0.8, birdPitch));

            // Yaw controls (A = left, D = right) with banking and upgrades
            let effectiveYawSpeed = yawSpeed;
            if (activeUpgrades['turning']) effectiveYawSpeed *= 1.3; // 30% faster
            if (activeUpgrades['ultra_agility']) effectiveYawSpeed *= 1.5; // 50% faster

            if (keys['a'] || keys['ArrowLeft']) {
                birdYaw += effectiveYawSpeed;
                bankingAngle = Math.min(bankingAngle + 0.05, 0.6); // Tilt left (positive)
            } else if (keys['d'] || keys['ArrowRight']) {
                birdYaw -= effectiveYawSpeed;
                bankingAngle = Math.max(bankingAngle - 0.05, -0.6); // Tilt right (negative)
            } else {
                // Return to level when not turning
                bankingAngle *= 0.9;
            }

            // Speed mechanics based on pitch
            // Diving (negative pitch) increases speed
            // Climbing (positive pitch) decreases speed
            const pitchSpeedEffect = -birdPitch * 0.015;
            forwardSpeed += pitchSpeedEffect;

            // Air resistance - gradually return to cruising speed when flying level
            // This prevents maintaining high dive speeds indefinitely
            const speedDifference = forwardSpeed - cruisingSpeed;
            const airResistance = speedDifference * 0.02; // 2% drag toward cruising speed
            forwardSpeed -= airResistance;

            // Speed boost with space and upgrades
            let currentSpeed = forwardSpeed;
            if (keys[' '] || keys['Space']) {
                let boostMultiplier = 1.8;
                if (activeUpgrades['mega_boost']) boostMultiplier = 3.6; // 2x more powerful
                currentSpeed *= boostMultiplier;
            }

            // Apply speed upgrades
            if (activeUpgrades['speed']) currentSpeed *= 1.2; // 20% faster
            if (activeUpgrades['mega_speed']) currentSpeed *= 1.5; // 50% faster

            // Depth-based speed bonuses
            if (activeUpgrades['deep_diver'] && bird.position.y < -40) {
                currentSpeed *= 1.2; // 20% faster below -40m
            }
            if (activeUpgrades['depth_master'] && bird.position.y < -60) {
                currentSpeed *= 1.4; // 40% faster below -60m
            }
            if (activeUpgrades['surface_swimmer'] && bird.position.y > -10) {
                currentSpeed *= 1.2; // 20% faster near surface
            }

            // Much faster underwater!
            if (isUnderwater) {
                currentSpeed *= 2.5; // 150% speed INCREASE underwater
            }

            // Clamp speed
            forwardSpeed = Math.max(minSpeed, Math.min(maxSpeed, forwardSpeed));
            currentSpeed = Math.max(minSpeed, Math.min(maxSpeed * 1.8, currentSpeed));

            // Calculate movement based on pitch and yaw
            const pitchCos = Math.cos(birdPitch);
            const pitchSin = Math.sin(birdPitch);

            // Move bird in 3D space based on orientation
            bird.position.x += Math.sin(birdYaw) * pitchCos * currentSpeed;
            bird.position.z += Math.cos(birdYaw) * pitchCos * currentSpeed;
            bird.position.y += pitchSin * currentSpeed;

            // Add gravity when above water (but only after grace period)!
            let effectiveGracePeriod = GRAVITY_GRACE_PERIOD;
            if (activeUpgrades['grace_period']) effectiveGracePeriod *= 2; // 2x longer
            if (!isUnderwater && timeAboveWater > effectiveGracePeriod) {
                bird.position.y -= 0.15; // Gravity pulls swordfish down
            }

            // Map boundary - keep bird within ocean area
            if (Math.abs(bird.position.x) > MAP_SIZE) {
                bird.position.x = Math.sign(bird.position.x) * MAP_SIZE;
                birdYaw += Math.PI; // Turn around
            }
            if (Math.abs(bird.position.z) > MAP_SIZE) {
                bird.position.z = Math.sign(bird.position.z) * MAP_SIZE;
                birdYaw += Math.PI; // Turn around
            }

            // Height limits
            if (bird.position.y > 80) {
                bird.position.y = 80;
                birdPitch = Math.min(birdPitch, 0);
            }

            // Ocean floor limit when diving (deep ocean)
            if (bird.position.y < -78) {
                bird.position.y = -78;
                birdPitch = Math.max(birdPitch, 0);
            }

            // Calculate actual velocity to determine visual pitch
            const actualVelocity = bird.position.clone().sub(previousPosition);
            const horizontalSpeed = Math.sqrt(actualVelocity.x * actualVelocity.x + actualVelocity.z * actualVelocity.z);
            const verticalSpeed = actualVelocity.y;

            // Calculate the actual flight path angle based on real velocity
            // This ensures the bird visually points in the direction it's actually moving
            let visualPitch = birdPitch;
            if (horizontalSpeed > 0.001) { // Avoid division by zero
                visualPitch = Math.atan2(verticalSpeed, horizontalSpeed);
            }

            // Update bird rotation with actual flight direction
            bird.rotation.y = birdYaw;
            bird.rotation.x = -visualPitch; // Use actual flight path angle
            bird.rotation.z = bankingAngle; // Enhanced banking effect when turning

            // Store current position for next frame's velocity calculation
            previousPosition.copy(bird.position);

            // Animate swordfish fins based on speed
            wingFlap += 0.1 + currentSpeed * 0.2;
            const flapAmount = 0.15 + currentSpeed * 0.1;
            leftWing.rotation.z = Math.sin(wingFlap) * flapAmount + Math.PI / 2.5;
            rightWing.rotation.z = -Math.sin(wingFlap) * flapAmount - Math.PI / 2.5;

            // Update motion trail
            trailIndex = (trailIndex + 1) % trailLength;
            trailPoints[trailIndex].copy(bird.position);
            trail.geometry.setFromPoints(trailPoints);
            trail.geometry.attributes.position.needsUpdate = true;

            // Smoothly decay mouse look offset when not looking
            if (!isMouseLooking && Math.abs(mouseLookYawOffset) > 0.01) {
                mouseLookYawOffset *= 0.85;
            }

            // Camera system - toggle between first-person and third-person
            if (isFirstPerson) {
                // First-person camera positioned at bird's head
                const headOffset = new THREE.Vector3(0, 0.5, 0.6); // Position at head
                headOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), -birdPitch); // Apply pitch rotation
                headOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), birdYaw); // Apply yaw rotation

                camera.position.copy(bird.position.clone().add(headOffset));

                // Camera looks in the direction modified by mouse look
                const lookYaw = birdYaw + mouseLookYawOffset;
                const lookDirection = new THREE.Vector3(
                    Math.sin(lookYaw) * Math.cos(birdPitch),
                    Math.sin(birdPitch),
                    Math.cos(lookYaw) * Math.cos(birdPitch)
                );
                const lookTarget = camera.position.clone().add(lookDirection.multiplyScalar(10));
                camera.lookAt(lookTarget);
            } else {
                // Third-person camera follows bird from behind with mouse look
                const cameraDistance = 10 + currentSpeed * 8;
                const cameraHeight = 3 - birdPitch * 8;
                // Apply mouse look offset to camera yaw
                const cameraYaw = birdYaw + mouseLookYawOffset;
                const cameraOffset = new THREE.Vector3(
                    Math.sin(cameraYaw) * -cameraDistance,
                    cameraHeight,
                    Math.cos(cameraYaw) * -cameraDistance
                );
                camera.position.lerp(bird.position.clone().add(cameraOffset), 0.08);
                camera.lookAt(bird.position);
            }

            // Move clouds slowly for parallax effect
            clouds.forEach((cloud, index) => {
                cloud.position.x += 0.008;
                cloud.position.z += Math.sin(index * 0.5) * 0.002;
                if (cloud.position.x > 150) {
                    cloud.position.x = -150;
                }
            });

            // Update fish behavior - OPTIMIZED BOID/FLOCKING ALGORITHM
            const CATCH_DISTANCE = 2.0;
            const PERCEPTION_RADIUS = 15.0; // Reduced for better performance
            const FLEE_RADIUS = 35.0; // Fish can see you from VERY far away!
            const SHARK_ATTRACTION_RADIUS = 20.0; // Stronger shark attraction
            const SEPARATION_DISTANCE = 1.5; // Hitbox distance - fish can't overlap

            // Staggered updates - only update a batch of fish per frame for performance
            const startIndex = fishUpdateOffset;
            const endIndex = Math.min(startIndex + FISH_UPDATE_BATCH_SIZE, fish.length);

            for (let i = fish.length - 1; i >= 0; i--) {
                const fishObj = fish[i];
                if (fishObj.userData.isCaught) continue;

                fishObj.userData.swimTime += 0.05;

                // Only do expensive boid calculations for fish in current batch
                const shouldUpdateBoid = (i >= startIndex && i < endIndex);

                // Calculate distance to player
                const dx = bird.position.x - fishObj.position.x;
                const dz = bird.position.z - fishObj.position.z;
                const dy = bird.position.y - fishObj.position.y;
                const distanceToBird = Math.sqrt(dx * dx + dz * dz + dy * dy);

                // Only calculate expensive boid forces for fish in current update batch
                if (shouldUpdateBoid) {
                    // BOID FORCES
                    const cohesion = new THREE.Vector3(0, 0, 0); // Move towards center of nearby fish
                    const separation = new THREE.Vector3(0, 0, 0); // Avoid crowding
                    const alignment = new THREE.Vector3(0, 0, 0); // Match velocity of nearby fish
                    const fleeForce = new THREE.Vector3(0, 0, 0); // Flee from player
                    const sharkAttraction = new THREE.Vector3(0, 0, 0); // Move towards nearest shark

                    let nearbyCount = 0;

                    // Check nearby fish for flocking behavior
                    for (let j = 0; j < fish.length; j++) {
                        if (i === j || fish[j].userData.isCaught) continue;

                        const other = fish[j];
                        const dist = fishObj.position.distanceTo(other.position);

                        if (dist < PERCEPTION_RADIUS) {
                            // Cohesion - move towards center of mass
                            cohesion.add(other.position);

                            // Alignment - match velocity
                            alignment.add(other.userData.velocity);

                            nearbyCount++;

                            // Separation - STRONG collision avoidance using hitbox radius
                            const minDistance = fishObj.userData.radius + other.userData.radius;
                            if (dist < SEPARATION_DISTANCE && dist > 0) {
                                const diff = new THREE.Vector3().subVectors(fishObj.position, other.position);
                                // Much stronger separation force when fish are too close (collision avoidance)
                                const separationStrength = dist < minDistance ? 0.5 : 0.15;
                                diff.divideScalar(dist); // Weight by distance
                                diff.multiplyScalar(separationStrength);
                                separation.add(diff);
                            }
                        }
                    }

                    if (nearbyCount > 0) {
                        cohesion.divideScalar(nearbyCount);
                        cohesion.sub(fishObj.position);
                        cohesion.normalize().multiplyScalar(0.08); // VERY strong cohesion - fish really stick together!

                        alignment.divideScalar(nearbyCount);
                        alignment.normalize().multiplyScalar(0.04); // Strong alignment for synchronized swimming

                        // Separation is already scaled per-fish above, just normalize the accumulated force
                        if (separation.length() > 0) {
                            separation.normalize().multiplyScalar(0.2); // Strong separation to prevent overlap
                        }
                    }

                    // Flee from player when close
                    if (distanceToBird < FLEE_RADIUS) {
                        fleeForce.set(-dx, -dy, -dz);
                        // Flee force gets stronger as you get closer
                        const fleeStrength = 0.3 * (1 - distanceToBird / FLEE_RADIUS);
                        fleeForce.normalize().multiplyScalar(0.3 + fleeStrength); // REALLY strong flee
                    }

                    // Attraction to nearest shark
                    let nearestSharkDist = Infinity;
                    let nearestShark = null;
                    for (let s = 0; s < sharks.length; s++) {
                        const sharkDist = fishObj.position.distanceTo(sharks[s].position);
                        if (sharkDist < nearestSharkDist && sharkDist < SHARK_ATTRACTION_RADIUS) {
                            nearestSharkDist = sharkDist;
                            nearestShark = sharks[s];
                        }
                    }

                    if (nearestShark) {
                        sharkAttraction.subVectors(nearestShark.position, fishObj.position);
                        sharkAttraction.normalize().multiplyScalar(0.04); // Stronger shark attraction
                    }

                    // Apply all forces to velocity
                    fishObj.userData.velocity.add(cohesion);
                    fishObj.userData.velocity.add(separation);
                    fishObj.userData.velocity.add(alignment);
                    fishObj.userData.velocity.add(fleeForce);
                    fishObj.userData.velocity.add(sharkAttraction);
                }

                // Limit speed
                const speed = fishObj.userData.velocity.length();
                if (speed > fishObj.userData.maxSpeed) {
                    fishObj.userData.velocity.normalize().multiplyScalar(fishObj.userData.maxSpeed);
                }

                // Apply velocity to position
                fishObj.position.add(fishObj.userData.velocity);

                // Keep fish underwater in deep ocean (between -75 and -2 meters)
                if (fishObj.position.y > -2) {
                    fishObj.position.y = -2;
                    fishObj.userData.verticalAngle = -Math.abs(fishObj.userData.verticalAngle);
                }
                if (fishObj.position.y < -75) {
                    fishObj.position.y = -75;
                    fishObj.userData.verticalAngle = Math.abs(fishObj.userData.verticalAngle);
                }

                // Keep fish within map boundaries
                const fishBoundary = MAP_SIZE - 50;
                if (Math.abs(fishObj.position.x) > fishBoundary) {
                    fishObj.position.x = Math.sign(fishObj.position.x) * fishBoundary;
                    fishObj.userData.wanderAngle = Math.PI - fishObj.userData.wanderAngle;
                }
                if (Math.abs(fishObj.position.z) > fishBoundary) {
                    fishObj.position.z = Math.sign(fishObj.position.z) * fishBoundary;
                    fishObj.userData.wanderAngle = -fishObj.userData.wanderAngle;
                }

                // Update fish rotation to face velocity direction
                if (fishObj.userData.velocity.length() > 0.01) {
                    const velocityAngle = Math.atan2(fishObj.userData.velocity.x, fishObj.userData.velocity.z);
                    const verticalAngle = Math.atan2(fishObj.userData.velocity.y,
                        Math.sqrt(fishObj.userData.velocity.x ** 2 + fishObj.userData.velocity.z ** 2));
                    fishObj.rotation.y = velocityAngle;
                    fishObj.rotation.x = -verticalAngle;
                }

                // Animate fish tail and fins
                const tailWag = Math.sin(fishObj.userData.swimTime * 5) * 0.3;
                if (fishObj.children[6]) { // Tail fin
                    fishObj.children[6].rotation.y = tailWag;
                }

                // Check if caught (only when bird is underwater)
                if (distanceToBird < CATCH_DISTANCE && isUnderwater) {
                    fishObj.userData.isCaught = true;
                    scene.remove(fishObj);
                    fish.splice(i, 1);

                    // Calculate fish catch count with upgrades
                    let fishCaught = 1;
                    if (activeUpgrades['double_catch']) {
                        fishCaught = 2; // Always catch 2
                    } else if (activeUpgrades['lucky'] && Math.random() < 0.1) {
                        fishCaught = 2; // 10% chance for 2
                    }
                    caughtFishCount += fishCaught;

                    // Increase hunger when eating fish with upgrades
                    let effectiveFishHunger = fishHungerGain;
                    if (activeUpgrades['fish_value']) effectiveFishHunger *= 1.25; // 25% more
                    hunger = Math.min(maxHunger, hunger + (effectiveFishHunger * fishCaught));

                    // Respawn fish
                    for (let f = 0; f < fishCaught; f++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 450;
                        const newFish = createFish(
                            Math.cos(angle) * distance,
                            Math.sin(angle) * distance
                        );
                        fish.push(newFish);
                        scene.add(newFish);
                    }
                }
            }

            // Update batch offset for next frame (cycle through all fish)
            fishUpdateOffset += FISH_UPDATE_BATCH_SIZE;
            if (fishUpdateOffset >= fish.length) {
                fishUpdateOffset = 0;
            }

            // Update shark behavior
            const SHARK_ATTACK_DISTANCE = 3.5; // Distance at which shark attacks
            let SHARK_CHASE_DISTANCE = 30; // Sharks can see you from a moderate distance

            // Apply shark vision upgrades
            if (activeUpgrades['stealth']) SHARK_CHASE_DISTANCE *= 0.7; // 30% reduction
            if (activeUpgrades['ghost_mode']) SHARK_CHASE_DISTANCE *= 0.2; // 80% reduction
            if (activeUpgrades['shark_repel']) SHARK_CHASE_DISTANCE = 10; // Sharks keep distance

            for (let i = 0; i < sharks.length; i++) {
                const shark = sharks[i];

                // Animate shark swimming
                shark.userData.swimTime += 0.03;

                // Calculate distance to bird
                const dx = bird.position.x - shark.position.x;
                const dz = bird.position.z - shark.position.z;
                const dy = bird.position.y - shark.position.y;
                const distanceToBird = Math.sqrt(dx * dx + dz * dz + dy * dy);

                // Shark AI: patrol or chase (ONLY chase when player is underwater - sharks can't see above water!)
                if (isUnderwater && bird.position.y < 0 && distanceToBird < SHARK_CHASE_DISTANCE) {
                    // Chase the bird!
                    const chaseAngle = Math.atan2(dx, dz);
                    const verticalChase = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));

                    shark.userData.patrolAngle = chaseAngle;
                    shark.userData.verticalAngle = verticalChase;

                    // Sharks swim faster when chasing - scary!
                    const chaseSpeed = shark.userData.swimSpeed * 1.4;
                    shark.position.x += Math.sin(chaseAngle) * chaseSpeed;
                    shark.position.z += Math.cos(chaseAngle) * chaseSpeed;
                    shark.position.y += Math.sin(verticalChase) * chaseSpeed * 0.5;
                } else {
                    // Normal patrol behavior
                    shark.userData.patrolAngle += (Math.random() - 0.5) * 0.05;
                    shark.userData.verticalAngle += (Math.random() - 0.5) * 0.02;
                    shark.userData.verticalAngle = Math.max(-0.2, Math.min(0.2, shark.userData.verticalAngle));

                    shark.position.x += Math.sin(shark.userData.patrolAngle) * shark.userData.swimSpeed;
                    shark.position.z += Math.cos(shark.userData.patrolAngle) * shark.userData.swimSpeed;
                    shark.position.y += Math.sin(shark.userData.verticalAngle) * shark.userData.swimSpeed * 0.3;
                }

                // Keep sharks underwater in deep ocean (between -75 and -3 meters)
                if (shark.position.y > -3) {
                    shark.position.y = -3;
                    shark.userData.verticalAngle = -Math.abs(shark.userData.verticalAngle);
                }
                if (shark.position.y < -75) {
                    shark.position.y = -75;
                    shark.userData.verticalAngle = Math.abs(shark.userData.verticalAngle);
                }

                // Keep sharks within map boundaries
                const sharkBoundary = MAP_SIZE - 50;
                if (Math.abs(shark.position.x) > sharkBoundary) {
                    shark.position.x = Math.sign(shark.position.x) * sharkBoundary;
                    shark.userData.patrolAngle = Math.PI - shark.userData.patrolAngle;
                }
                if (Math.abs(shark.position.z) > sharkBoundary) {
                    shark.position.z = Math.sign(shark.position.z) * sharkBoundary;
                    shark.userData.patrolAngle = -shark.userData.patrolAngle;
                }

                // Update shark rotation to face movement direction
                shark.rotation.y = shark.userData.patrolAngle;
                shark.rotation.x = shark.userData.verticalAngle;

                // Animate shark tail
                const tailWag = Math.sin(shark.userData.swimTime * 4) * 0.2;
                if (shark.children[7]) { // Tail fin
                    shark.children[7].rotation.y = tailWag;
                }

                // Sharks eat fish
                const SHARK_EAT_DISTANCE = 2.5;
                for (let j = fish.length - 1; j >= 0; j--) {
                    const fishObj = fish[j];
                    if (fishObj.userData.isCaught) continue;

                    const fishDist = shark.position.distanceTo(fishObj.position);
                    if (fishDist < SHARK_EAT_DISTANCE) {
                        // Shark eats the fish
                        scene.remove(fishObj);
                        fish.splice(j, 1);

                        // Respawn a new fish in a random location
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 450;
                        const newFish = createFish(
                            Math.cos(angle) * distance,
                            Math.sin(angle) * distance
                        );
                        fish.push(newFish);
                        scene.add(newFish);
                        break; // Shark only eats one fish per frame
                    }
                }

                // Check if shark caught the swordfish (game over)
                const isVulnerable = isUnderwater || !activeUpgrades['invincible_jump'];
                if (distanceToBird < SHARK_ATTACK_DISTANCE && isVulnerable) {
                    // Shark attack! Reset position and lose some fish
                    bird.position.set(0, -5, 0);
                    birdPitch = 0;
                    birdYaw = 0;
                    airTime = maxAirTime;
                    hunger = maxHunger; // Reset hunger to max on death

                    // Lose half of caught fish
                    const fishLost = Math.floor(caughtFishCount / 2);
                    caughtFishCount -= fishLost;

                    // Visual feedback
                    console.log("Shark attack! Lost " + fishLost + " fish!");
                }
            }

            // Shark respawning - add new sharks periodically to maintain population
            sharkSpawnTimer++;
            if (sharkSpawnTimer >= sharkSpawnInterval && sharks.length < 20) {
                sharkSpawnTimer = 0;
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 350 + 50;
                const newShark = createShark(
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance
                );
                newShark.position.y = -10 - Math.random() * 50;
                sharks.push(newShark);
                scene.add(newShark);
            }

            // Update stats with color coding
            const speedElement = document.getElementById('speed');
            const speedValue = currentSpeed.toFixed(3);
            speedElement.textContent = speedValue;

            // Color code speed
            if (currentSpeed > 0.5) {
                speedElement.className = 'speed-indicator high-speed';
            } else if (currentSpeed < 0.25) {
                speedElement.className = 'speed-indicator low-speed';
            } else {
                speedElement.className = 'speed-indicator';
            }

            document.getElementById('altitude').textContent = Math.round(bird.position.y);
            document.getElementById('pitch').textContent = Math.round(birdPitch * 57.3); // Convert to degrees
            document.getElementById('position').textContent =
                `${Math.round(bird.position.x)}, ${Math.round(bird.position.z)}`;
            document.getElementById('caughtFish').textContent = caughtFishCount;
            document.getElementById('hunger').textContent = Math.round(hunger);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>

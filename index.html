<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bird Flying Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }

        #instructions h2 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        #instructions ul {
            list-style-position: inside;
            margin-left: 10px;
        }

        #instructions li {
            margin: 5px 0;
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            min-width: 200px;
        }

        #stats div {
            margin: 5px 0;
        }

        .speed-indicator {
            font-weight: bold;
        }

        .high-speed {
            color: #ff4444;
        }

        .low-speed {
            color: #44ff44;
        }

        #oxygenBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 3px;
            display: none;
        }

        #oxygenFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0099ff);
            border-radius: 12px;
            transition: width 0.3s ease;
        }

        #underwaterOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(0, 80, 120, 0.3) 0%, rgba(0, 40, 80, 0.6) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #hungerBar {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff9900;
            border-radius: 15px;
            padding: 3px;
        }

        #hungerFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff9900);
            border-radius: 12px;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>üó°Ô∏è Swordfish Hunter</h2>
        <ul>
            <li><strong>W/‚Üë</strong> - Pitch up</li>
            <li><strong>S/‚Üì</strong> - Pitch down</li>
            <li><strong>A/‚Üê</strong> - Turn left</li>
            <li><strong>D/‚Üí</strong> - Turn right</li>
            <li><strong>Space</strong> - Speed boost</li>
            <li><strong>E or Click</strong> - Shoot gun</li>
            <li><strong>F</strong> - Toggle 1st/3rd person view</li>
        </ul>
        <p style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
            You're an armed swordfish! Hunt fish, shoot barracudas, avoid sharks, and explore the kelp forest!
        </p>
    </div>

    <div id="stats">
        <div>Altitude: <span id="altitude">0</span>m</div>
        <div>Speed: <span id="speed" class="speed-indicator">0</span></div>
        <div>Pitch: <span id="pitch">0</span>¬∞</div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Fish Caught: <span id="caughtFish">0</span></div>
        <div>Hunger: <span id="hunger">100</span>%</div>
    </div>

    <div id="oxygenBar">
        <div id="oxygenFill"></div>
    </div>

    <div id="hungerBar">
        <div id="hungerFill"></div>
    </div>

    <div id="underwaterOverlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Ocean sky with gradient
        const skyColor = 0x5BA3D0; // Ocean blue sky
        const horizonColor = 0xffffff;
        scene.background = new THREE.Color(skyColor);
        scene.fog = new THREE.FogExp2(0x5BA3D0, 0.001);

        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xfff5e1, 1.2);
        directionalLight.position.set(100, 150, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // Add hemisphere light for better ambient lighting
        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.5);
        scene.add(hemisphereLight);

        // Create swordfish (player)
        const bird = new THREE.Group();

        // Swordfish body (streamlined)
        const bodyGeometry = new THREE.SphereGeometry(0.4, 32, 32);
        bodyGeometry.scale(1, 0.9, 2.5);
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x1E40AF, // Deep blue
            metalness: 0.6,
            roughness: 0.3,
            emissive: 0x0000FF,
            emissiveIntensity: 0.1
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        bird.add(body);

        // Swordfish underbelly (lighter)
        const bellyGeometry = new THREE.SphereGeometry(0.35, 32, 32);
        bellyGeometry.scale(1, 0.7, 2.2);
        const bellyMaterial = new THREE.MeshStandardMaterial({
            color: 0xE0E7FF, // Light blue
            metalness: 0.5,
            roughness: 0.4
        });
        const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
        belly.position.y = -0.2;
        bird.add(belly);

        // Sword/Bill (long pointed nose)
        const swordGeometry = new THREE.ConeGeometry(0.08, 1.5, 8);
        const swordMaterial = new THREE.MeshStandardMaterial({
            color: 0x6B7280,
            metalness: 0.8,
            roughness: 0.2
        });
        const sword = new THREE.Mesh(swordGeometry, swordMaterial);
        sword.position.set(0, 0, 1.5);
        sword.rotation.x = Math.PI / 2;
        sword.castShadow = true;
        bird.add(sword);

        // Swordfish eyes
        const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.25, 0.2, 0.7);
        bird.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.25, 0.2, 0.7);
        bird.add(rightEye);

        // Eye pupils
        const pupilGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        leftPupil.position.set(-0.25, 0.2, 0.75);
        bird.add(leftPupil);
        const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        rightPupil.position.set(0.25, 0.2, 0.75);
        bird.add(rightPupil);

        // Dorsal fin
        const dorsalFinGeometry = new THREE.ConeGeometry(0.25, 0.8, 8);
        const finMaterial = new THREE.MeshStandardMaterial({
            color: 0x1E40AF,
            metalness: 0.5,
            roughness: 0.4
        });
        const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
        dorsalFin.position.set(0, 0.6, -0.3);
        dorsalFin.rotation.x = Math.PI;
        dorsalFin.castShadow = true;
        bird.add(dorsalFin);

        // Pectoral fins (side fins)
        const pectoralFinGeometry = new THREE.ConeGeometry(0.2, 0.6, 8);
        const leftWing = new THREE.Mesh(pectoralFinGeometry, finMaterial);
        leftWing.position.set(-0.4, 0, 0.2);
        leftWing.rotation.z = Math.PI / 2.5;
        leftWing.castShadow = true;
        bird.add(leftWing);

        const rightWing = new THREE.Mesh(pectoralFinGeometry, finMaterial);
        rightWing.position.set(0.4, 0, 0.2);
        rightWing.rotation.z = -Math.PI / 2.5;
        rightWing.castShadow = true;
        bird.add(rightWing);

        // Tail fin (crescent shaped)
        const tailGeometry = new THREE.ConeGeometry(0.45, 1.0, 8);
        const tail = new THREE.Mesh(tailGeometry, finMaterial);
        tail.position.set(0, 0, -1.2);
        tail.rotation.x = Math.PI / 2;
        tail.castShadow = true;
        bird.add(tail);

        // Gun attached to the swordfish
        const gunGroup = new THREE.Group();

        // Gun barrel
        const barrelGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
        const barrelMaterial = new THREE.MeshStandardMaterial({
            color: 0x2C3E50,
            metalness: 0.9,
            roughness: 0.2
        });
        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
        barrel.rotation.z = Math.PI / 2;
        barrel.position.set(0, 0, 0.6);
        gunGroup.add(barrel);

        // Gun grip
        const gripGeometry = new THREE.BoxGeometry(0.15, 0.25, 0.15);
        const gripMaterial = new THREE.MeshStandardMaterial({
            color: 0x1A1A1A,
            metalness: 0.5,
            roughness: 0.7
        });
        const grip = new THREE.Mesh(gripGeometry, gripMaterial);
        grip.position.set(0, -0.15, 0.2);
        gunGroup.add(grip);

        // Muzzle tip
        const muzzleGeometry = new THREE.CylinderGeometry(0.06, 0.1, 0.15, 8);
        const muzzle = new THREE.Mesh(muzzleGeometry, barrelMaterial);
        muzzle.rotation.z = Math.PI / 2;
        muzzle.position.set(0, 0, 1.25);
        gunGroup.add(muzzle);

        // Position gun on the right side of the swordfish
        gunGroup.position.set(0.3, -0.1, 0.5);
        gunGroup.rotation.y = -0.1;
        bird.add(gunGroup);

        bird.position.set(0, -5, 0); // Start underwater
        scene.add(bird);

        // Motion trail
        const trailPoints = [];
        const trailLength = 20;
        for (let i = 0; i < trailLength; i++) {
            trailPoints.push(new THREE.Vector3(0, -5, 0));
        }
        const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
        const trailMaterial = new THREE.LineBasicMaterial({
            color: 0x1E40AF, // Blue swordfish trail
            transparent: true,
            opacity: 0.4,
            linewidth: 2
        });
        const trail = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trail);

        // Ocean surface with animated waves
        const oceanGeometry = new THREE.PlaneGeometry(2000, 2000, 150, 150);
        const oceanMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            roughness: 0.4,
            metalness: 0.6,
            transparent: true,
            opacity: 0.9
        });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.y = 0;
        ocean.receiveShadow = true;

        // Store original positions for wave animation
        const oceanPositions = ocean.geometry.attributes.position;
        const originalPositions = new Float32Array(oceanPositions.count * 3);
        const waveRandomness = new Float32Array(oceanPositions.count); // Random amplitude for each vertex
        for (let i = 0; i < oceanPositions.count; i++) {
            originalPositions[i * 3] = oceanPositions.getX(i);
            originalPositions[i * 3 + 1] = oceanPositions.getY(i);
            originalPositions[i * 3 + 2] = oceanPositions.getZ(i);
            waveRandomness[i] = 0.5 + Math.random() * 1.5; // Random multiplier between 0.5 and 2.0
        }

        scene.add(ocean);

        // Ocean floor
        const oceanFloorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        const oceanFloorMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B7355, // Sandy brown
            roughness: 0.95,
            metalness: 0.05
        });
        const oceanFloor = new THREE.Mesh(oceanFloorGeometry, oceanFloorMaterial);
        oceanFloor.rotation.x = -Math.PI / 2;
        oceanFloor.position.y = -80; // Ocean floor at -80m (DEEP ocean)
        oceanFloor.receiveShadow = true;

        // Add variation to ocean floor for terrain effect
        const floorPositions = oceanFloor.geometry.attributes.position;
        for (let i = 0; i < floorPositions.count; i++) {
            const variation = Math.random() * 0.5 + Math.sin(i * 0.1) * 0.3;
            floorPositions.setZ(i, variation);
        }
        floorPositions.needsUpdate = true;
        oceanFloor.geometry.computeVertexNormals();

        scene.add(oceanFloor);

        // Create enhanced clouds
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.7,
                roughness: 1,
                metalness: 0
            });

            for (let i = 0; i < 7; i++) {
                const cloudPart = new THREE.Mesh(
                    new THREE.SphereGeometry(Math.random() * 2.5 + 1.5, 16, 16),
                    cloudMaterial
                );
                cloudPart.position.set(
                    Math.random() * 5 - 2.5,
                    Math.random() * 2 - 1,
                    Math.random() * 5 - 2.5
                );
                cloud.add(cloudPart);
            }

            cloud.position.set(x, y, z);
            return cloud;
        }

        // Add multiple clouds at various heights
        const clouds = [];
        for (let i = 0; i < 30; i++) {
            const cloud = createCloud(
                Math.random() * 300 - 150,
                Math.random() * 40 + 20,
                Math.random() * 300 - 150
            );
            clouds.push(cloud);
            scene.add(cloud);
        }

        // Create underwater kelp/trees
        function createKelp(x, z) {
            const kelp = new THREE.Group();

            // Kelp stalk (tall and wavy)
            const stalkHeight = 8 + Math.random() * 12; // Varied heights
            const stalkGeometry = new THREE.CylinderGeometry(0.15, 0.2, stalkHeight, 8);
            const stalkMaterial = new THREE.MeshStandardMaterial({
                color: 0x2E5C3C, // Dark green
                roughness: 0.8,
                metalness: 0.1
            });
            const stalk = new THREE.Mesh(stalkGeometry, stalkMaterial);
            stalk.position.y = stalkHeight / 2 - 70; // Plant on ocean floor
            stalk.castShadow = true;
            kelp.add(stalk);

            // Kelp leaves (flowing)
            const leafMaterial = new THREE.MeshStandardMaterial({
                color: 0x3A7D44, // Lighter green
                roughness: 0.7,
                metalness: 0.2,
                side: THREE.DoubleSide
            });

            const numLeaves = Math.floor(Math.random() * 8) + 5;
            for (let i = 0; i < numLeaves; i++) {
                const leafGeometry = new THREE.ConeGeometry(
                    0.5 + Math.random() * 0.5,
                    2 + Math.random() * 1.5,
                    6
                );
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                const leafHeight = (i / numLeaves) * stalkHeight - 70 + stalkHeight / 2;
                const leafAngle = (i / numLeaves) * Math.PI * 2;
                leaf.position.set(
                    Math.cos(leafAngle) * 0.3,
                    leafHeight,
                    Math.sin(leafAngle) * 0.3
                );
                leaf.rotation.z = Math.PI / 6 + Math.random() * 0.3;
                leaf.rotation.y = leafAngle;
                kelp.add(leaf);
            }

            kelp.position.set(x, 0, z);
            kelp.userData.swayOffset = Math.random() * Math.PI * 2;
            kelp.userData.swaySpeed = 0.5 + Math.random() * 0.5;

            return kelp;
        }

        // Spawn kelp all around the map
        const kelpForest = [];
        const NUM_KELP = 150; // Lots of kelp!
        for (let i = 0; i < NUM_KELP; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 480; // Spread across the map
            const kelp = createKelp(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            kelpForest.push(kelp);
            scene.add(kelp);
        }

        const MAP_SIZE = 500; // Larger ocean area

        // Create fish
        function createFish(x, z) {
            const fish = new THREE.Group();

            // Fish colors - variety of ocean fish
            const fishColors = [
                0xFF6B35, // Orange
                0xFFD23F, // Yellow
                0x00A6ED, // Blue
                0xFF006E, // Pink
                0x3BCEAC, // Teal
                0xA463F2, // Purple
            ];
            const fishColor = fishColors[Math.floor(Math.random() * fishColors.length)];

            // Fish body (elongated sphere)
            const bodyGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            bodyGeometry.scale(1, 0.9, 1.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: fishColor,
                roughness: 0.4,
                metalness: 0.5,
                emissive: fishColor,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            fish.add(body);

            // Fish eyes
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeWhiteMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
            leftEye.position.set(-0.15, 0.12, 0.35);
            fish.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
            rightEye.position.set(0.15, 0.12, 0.35);
            fish.add(rightEye);

            // Eye pupils
            const pupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.15, 0.12, 0.41);
            fish.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.15, 0.12, 0.41);
            fish.add(rightPupil);

            // Dorsal fin (top fin)
            const dorsalFinGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const finMaterial = new THREE.MeshStandardMaterial({
                color: fishColor,
                roughness: 0.5,
                metalness: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
            dorsalFin.position.set(0, 0.35, 0);
            dorsalFin.rotation.x = Math.PI;
            fish.add(dorsalFin);

            // Side fins
            const sideFinsGeometry = new THREE.ConeGeometry(0.12, 0.3, 8);
            const leftFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            leftFin.position.set(-0.25, -0.05, 0.1);
            leftFin.rotation.z = Math.PI / 3;
            fish.add(leftFin);
            const rightFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            rightFin.position.set(0.25, -0.05, 0.1);
            rightFin.rotation.z = -Math.PI / 3;
            fish.add(rightFin);

            // Tail fin
            const tailGeometry = new THREE.ConeGeometry(0.25, 0.5, 8);
            const tail = new THREE.Mesh(tailGeometry, finMaterial);
            tail.position.set(0, 0, -0.5);
            tail.rotation.x = -Math.PI / 2;
            fish.add(tail);

            // Start fish at various depths in deep ocean
            const depth = -2 - Math.random() * 60; // Between -2 and -62 meters
            fish.position.set(x, depth, z);

            // Add custom properties for behavior (boid/flocking)
            fish.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,
                (Math.random() - 0.5) * 0.08,
                (Math.random() - 0.5) * 0.15
            );
            fish.userData.swimSpeed = 0.18; // Even slower swimming fish
            fish.userData.maxSpeed = 0.24; // Further reduced max speed
            fish.userData.isCaught = false;
            fish.userData.swimTime = Math.random() * 100;
            fish.userData.radius = 0.5; // Collision radius for hitbox

            return fish;
        }

        // Spawn fish across the ocean - HUGE MASSIVE PACKS!
        const fish = [];
        const NUM_FISH = 1500; // MASSIVE schools of fish!

        // Spawn fish in large clusters for big pack behavior
        const NUM_CLUSTERS = 20; // Number of major fish schools
        for (let cluster = 0; cluster < NUM_CLUSTERS; cluster++) {
            // Each cluster has a center point
            const clusterAngle = Math.random() * Math.PI * 2;
            const clusterDistance = Math.random() * 400;
            const clusterX = Math.cos(clusterAngle) * clusterDistance;
            const clusterZ = Math.sin(clusterAngle) * clusterDistance;

            // Spawn many fish around this cluster center
            const fishPerCluster = Math.floor(NUM_FISH / NUM_CLUSTERS);
            for (let i = 0; i < fishPerCluster; i++) {
                // Fish spawn close to cluster center
                const offsetAngle = Math.random() * Math.PI * 2;
                const offsetDistance = Math.random() * 30; // Cluster radius
                const newFish = createFish(
                    clusterX + Math.cos(offsetAngle) * offsetDistance,
                    clusterZ + Math.sin(offsetAngle) * offsetDistance
                );
                fish.push(newFish);
                scene.add(newFish);
            }
        }

        let caughtFishCount = 0;

        // Projectile system
        const projectiles = [];
        const PROJECTILE_SPEED = 2.0;
        const PROJECTILE_LIFETIME = 3000; // 3 seconds in milliseconds
        let lastShootTime = 0;
        const SHOOT_COOLDOWN = 200; // 200ms between shots

        function createProjectile(position, direction) {
            const projectileGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const projectileMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.8,
                metalness: 0.5,
                roughness: 0.3
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            projectile.castShadow = true;

            // Add glowing trail
            const trailGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFAA00,
                transparent: true,
                opacity: 0.5
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            projectile.add(trail);

            projectile.userData.velocity = direction.clone().normalize().multiplyScalar(PROJECTILE_SPEED);
            projectile.userData.createdAt = Date.now();

            scene.add(projectile);
            projectiles.push(projectile);

            return projectile;
        }

        function shootProjectile() {
            const currentTime = Date.now();
            if (currentTime - lastShootTime < SHOOT_COOLDOWN) return;

            lastShootTime = currentTime;

            // Calculate gun muzzle position in world space
            const muzzleOffset = new THREE.Vector3(0.3, -0.1, 1.8);
            muzzleOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), -birdPitch);
            muzzleOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), birdYaw);
            const muzzlePosition = bird.position.clone().add(muzzleOffset);

            // Calculate shooting direction
            const pitchCos = Math.cos(birdPitch);
            const pitchSin = Math.sin(birdPitch);
            const shootDirection = new THREE.Vector3(
                Math.sin(birdYaw) * pitchCos,
                pitchSin,
                Math.cos(birdYaw) * pitchCos
            );

            createProjectile(muzzlePosition, shootDirection);
        }

        // Create sharks
        function createShark(x, z) {
            const shark = new THREE.Group();

            // Shark body (elongated and larger)
            const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            bodyGeometry.scale(1, 0.8, 2.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568, // Dark gray
                roughness: 0.6,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            shark.add(body);

            // Shark underbelly (lighter)
            const bellyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            bellyGeometry.scale(1, 0.6, 2.2);
            const bellyMaterial = new THREE.MeshStandardMaterial({
                color: 0xE5E7EB, // Light gray
                roughness: 0.6,
                metalness: 0.2
            });
            const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
            belly.position.y = -0.2;
            shark.add(belly);

            // Shark head/snout
            const snoutGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const snoutMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568,
                roughness: 0.6,
                metalness: 0.3
            });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0, 0, 1.5);
            snout.rotation.x = Math.PI / 2;
            shark.add(snout);

            // Shark eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.25, 0.2, 1.1);
            shark.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.25, 0.2, 1.1);
            shark.add(rightEye);

            // Dorsal fin (top)
            const dorsalFinGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568,
                roughness: 0.6,
                metalness: 0.3
            });
            const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
            dorsalFin.position.set(0, 0.6, -0.2);
            dorsalFin.rotation.x = Math.PI;
            shark.add(dorsalFin);

            // Side fins
            const sideFinsGeometry = new THREE.ConeGeometry(0.25, 0.6, 8);
            const leftFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            leftFin.position.set(-0.5, -0.1, 0.3);
            leftFin.rotation.z = Math.PI / 2.5;
            shark.add(leftFin);
            const rightFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            rightFin.position.set(0.5, -0.1, 0.3);
            rightFin.rotation.z = -Math.PI / 2.5;
            shark.add(rightFin);

            // Tail fin
            const tailGeometry = new THREE.ConeGeometry(0.4, 1.0, 8);
            const tail = new THREE.Mesh(tailGeometry, finMaterial);
            tail.position.set(0, 0.2, -1.5);
            tail.rotation.x = -Math.PI / 2;
            shark.add(tail);

            shark.position.set(x, -20, z); // Patrol at mid-depth in deep ocean

            // Add custom properties for behavior
            shark.userData.velocity = new THREE.Vector3(0, 0, 0);
            shark.userData.swimSpeed = 0.55; // Slightly faster than player for chase tension
            shark.userData.patrolAngle = Math.random() * Math.PI * 2;
            shark.userData.verticalAngle = 0;
            shark.userData.swimTime = Math.random() * 100;
            shark.userData.isShark = true;

            // Store original spawn position for respawning
            shark.userData.spawnX = x;
            shark.userData.spawnZ = z;
            shark.userData.spawnY = -20;

            return shark;
        }

        // Spawn many sharks
        const sharks = [];
        const NUM_SHARKS = 15; // Lots of sharks!
        for (let i = 0; i < NUM_SHARKS; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 350 + 50;
            const newShark = createShark(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            // Vary shark starting depths in deep ocean
            const spawnY = -10 - Math.random() * 50; // Between -10 and -60
            newShark.position.y = spawnY;
            newShark.userData.spawnY = spawnY; // Store actual spawn Y
            sharks.push(newShark);
            scene.add(newShark);
        }

        // Create aggressive barracudas (fast enemies that chase player)
        function createBarracuda(x, z) {
            const barracuda = new THREE.Group();

            // Barracuda body (sleek and aggressive)
            const bodyGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            bodyGeometry.scale(1, 0.7, 3.0); // Very elongated
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x708090, // Steel gray
                roughness: 0.4,
                metalness: 0.6,
                emissive: 0xFF0000,
                emissiveIntensity: 0.2 // Red glow - aggressive!
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            barracuda.add(body);

            // Sharp teeth/jaw
            const jawGeometry = new THREE.ConeGeometry(0.15, 0.4, 6);
            const jawMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.3,
                metalness: 0.7
            });
            const jaw = new THREE.Mesh(jawGeometry, jawMaterial);
            jaw.position.set(0, -0.1, 1.0);
            jaw.rotation.x = Math.PI / 2;
            barracuda.add(jaw);

            // Glowing red eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 1.0
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.18, 0.15, 0.8);
            barracuda.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.18, 0.15, 0.8);
            barracuda.add(rightEye);

            // Dorsal fin (spiky)
            const dorsalFinGeometry = new THREE.ConeGeometry(0.2, 0.6, 6);
            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0x556B2F,
                roughness: 0.5,
                metalness: 0.4
            });
            const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
            dorsalFin.position.set(0, 0.4, 0);
            dorsalFin.rotation.x = Math.PI;
            barracuda.add(dorsalFin);

            // Side fins
            const sideFinsGeometry = new THREE.ConeGeometry(0.15, 0.4, 6);
            const leftFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            leftFin.position.set(-0.3, -0.05, 0.3);
            leftFin.rotation.z = Math.PI / 3;
            barracuda.add(leftFin);
            const rightFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            rightFin.position.set(0.3, -0.05, 0.3);
            rightFin.rotation.z = -Math.PI / 3;
            barracuda.add(rightFin);

            // Tail
            const tailGeometry = new THREE.ConeGeometry(0.3, 0.8, 6);
            const tail = new THREE.Mesh(tailGeometry, finMaterial);
            tail.position.set(0, 0, -1.0);
            tail.rotation.x = -Math.PI / 2;
            barracuda.add(tail);

            barracuda.position.set(x, -15, z);

            // Barracudas are VERY aggressive and fast
            barracuda.userData.velocity = new THREE.Vector3(0, 0, 0);
            barracuda.userData.swimSpeed = 0.75; // Faster than sharks!
            barracuda.userData.patrolAngle = Math.random() * Math.PI * 2;
            barracuda.userData.verticalAngle = 0;
            barracuda.userData.swimTime = Math.random() * 100;
            barracuda.userData.isBarracuda = true;
            barracuda.userData.health = 2; // Takes 2 hits to kill

            // Store original spawn position for respawning
            barracuda.userData.spawnX = x;
            barracuda.userData.spawnZ = z;
            barracuda.userData.spawnY = -15;

            return barracuda;
        }

        // Spawn barracudas
        const barracudas = [];
        const NUM_BARRACUDAS = 25; // Many aggressive enemies!
        for (let i = 0; i < NUM_BARRACUDAS; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 400 + 50;
            const newBarracuda = createBarracuda(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            const spawnY = -5 - Math.random() * 60; // Spread throughout depth
            newBarracuda.position.y = spawnY;
            newBarracuda.userData.spawnY = spawnY; // Store actual spawn Y
            barracudas.push(newBarracuda);
            scene.add(newBarracuda);
        }

        // Reset all enemies to safe positions (far from spawn point)
        function resetAllEnemies() {
            const SAFE_SPAWN_DISTANCE = 100; // Minimum distance from player spawn (0, -5, 0)
            const SHARK_CHASE_DISTANCE = 60; // Same as in animation loop

            // Reset sharks
            sharks.forEach(shark => {
                // Check if spawn position is too close to player spawn
                const distanceFromSpawn = Math.sqrt(
                    shark.userData.spawnX * shark.userData.spawnX +
                    shark.userData.spawnZ * shark.userData.spawnZ
                );

                if (distanceFromSpawn < SAFE_SPAWN_DISTANCE) {
                    // Respawn far away
                    const angle = Math.random() * Math.PI * 2;
                    const distance = SAFE_SPAWN_DISTANCE + Math.random() * 300;
                    shark.userData.spawnX = Math.cos(angle) * distance;
                    shark.userData.spawnZ = Math.sin(angle) * distance;
                }

                // Reset to spawn position
                shark.position.set(
                    shark.userData.spawnX,
                    shark.userData.spawnY,
                    shark.userData.spawnZ
                );
                shark.userData.patrolAngle = Math.random() * Math.PI * 2;
                shark.userData.verticalAngle = 0;
                shark.userData.velocity.set(0, 0, 0);
            });

            // Reset barracudas
            barracudas.forEach(barracuda => {
                // Check if spawn position is too close to player spawn
                const distanceFromSpawn = Math.sqrt(
                    barracuda.userData.spawnX * barracuda.userData.spawnX +
                    barracuda.userData.spawnZ * barracuda.userData.spawnZ
                );

                if (distanceFromSpawn < SAFE_SPAWN_DISTANCE) {
                    // Respawn far away
                    const angle = Math.random() * Math.PI * 2;
                    const distance = SAFE_SPAWN_DISTANCE + Math.random() * 350;
                    barracuda.userData.spawnX = Math.cos(angle) * distance;
                    barracuda.userData.spawnZ = Math.sin(angle) * distance;
                }

                // Reset to spawn position
                barracuda.position.set(
                    barracuda.userData.spawnX,
                    barracuda.userData.spawnY,
                    barracuda.userData.spawnZ
                );
                barracuda.userData.patrolAngle = Math.random() * Math.PI * 2;
                barracuda.userData.verticalAngle = 0;
                barracuda.userData.velocity.set(0, 0, 0);
                barracuda.userData.health = 2; // Reset health
            });
        }

        // Camera setup
        camera.position.set(0, -3, -10);
        camera.lookAt(bird.position);

        // Game state with momentum system
        const keys = {};
        let birdYaw = 0; // Horizontal rotation (left/right)
        let birdPitch = 0; // Vertical rotation (up/down)
        let forwardSpeed = 0.3; // Current forward speed
        const minSpeed = 0.15;
        const maxSpeed = 0.8;
        const cruisingSpeed = 0.3; // Natural cruising speed when flying level
        const pitchSpeed = 0.025; // How fast pitch changes
        const yawSpeed = 0.03; // How fast yaw changes
        const pitchDecay = 0.92; // How quickly pitch returns to neutral
        let wingFlap = 0;
        let trailIndex = 0;
        let bankingAngle = 0; // Current tilt angle when turning
        let isFirstPerson = true; // Camera mode: true = first-person, false = third-person
        let previousPosition = new THREE.Vector3(0, -5, 0); // Track previous position for velocity calculation

        // Underwater / jumping mechanics
        let isUnderwater = false;
        let airTime = 100; // Air time when above water (0-100)
        const maxAirTime = 100;
        const airTimeDepletionRate = 0.5; // Per frame when above water
        const airTimeRecoveryRate = 2.0; // Per frame when underwater (quick recovery)
        let waveTime = 0; // For wave animation
        let timeAboveWater = 0; // Track how long we've been above water
        const GRAVITY_GRACE_PERIOD = 1.5; // Seconds before gravity kicks in

        // Hunger system
        let hunger = 100; // Hunger level (0-100)
        const maxHunger = 100;
        const hungerDepletionRate = 0.05; // Passive hunger loss per frame
        const boostHungerCost = 0.8; // Hunger cost per frame when boosting
        const fishHungerGain = 15; // Hunger gained from eating a fish

        // Shark respawning
        let sharkSpawnTimer = 0;
        const sharkSpawnInterval = 600; // Spawn a new shark every ~10 seconds (at 60fps)

        // Fish AI optimization - staggered updates
        let fishUpdateOffset = 0; // Which group of fish to update this frame
        const FISH_UPDATE_BATCH_SIZE = 150; // Update 150 fish per frame (10% of 1500)

        // Mouse look controls
        let isMouseLooking = false;
        let mouseLookYawOffset = 0; // Horizontal camera rotation offset from mouse
        let mouseStartX = 0;
        const mouseSensitivity = 0.008; // How much mouse movement affects camera (higher = more sensitive)

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;

            // Toggle camera mode with F key
            if (e.key === 'f' || e.key === 'F') {
                isFirstPerson = !isFirstPerson;
                console.log('Camera mode:', isFirstPerson ? 'First Person' : 'Third Person');
            }

            // Shoot with E key
            if (e.key === 'e' || e.key === 'E') {
                shootProjectile();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        // Mouse look controls - hold right click to look around, left click to shoot
        let mouseDownX = 0;
        let mouseHasMoved = false;

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                // Left click - prepare for shoot or look
                mouseDownX = e.clientX;
                mouseHasMoved = false;
            } else if (e.button === 2) {
                // Right click - look around
                isMouseLooking = true;
                mouseStartX = e.clientX;
                e.preventDefault(); // Prevent context menu on right click
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                // Left click release - shoot if didn't move much (wasn't looking around)
                if (!mouseHasMoved) {
                    shootProjectile();
                }
            } else if (e.button === 2) {
                isMouseLooking = false;
                // Smoothly return camera to center
                mouseLookYawOffset *= 0.9;
            }
        });

        window.addEventListener('mousemove', (e) => {
            // Track if mouse moved during left click
            if (e.buttons === 1) { // Left button held
                const deltaX = Math.abs(e.clientX - mouseDownX);
                if (deltaX > 5) {
                    mouseHasMoved = true;
                }
            }

            if (isMouseLooking) {
                const deltaX = e.clientX - mouseStartX;
                mouseLookYawOffset = deltaX * mouseSensitivity;
                // Limit how far you can look around (approximately 180 degrees left/right)
                mouseLookYawOffset = Math.max(-Math.PI, Math.min(Math.PI, mouseLookYawOffset));
            }
        });

        // Prevent context menu on right click
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop with momentum-based physics
        function animate() {
            requestAnimationFrame(animate);

            // Animate ocean waves - RANDOM SIZE WAVES!
            waveTime += 0.02;
            for (let i = 0; i < oceanPositions.count; i++) {
                const x = originalPositions[i * 3];
                const y = originalPositions[i * 3 + 1];
                const z = originalPositions[i * 3 + 2];

                // Create wave pattern with random amplitudes for varied wave sizes
                const randomAmp = waveRandomness[i];
                const wave1 = Math.sin(x * 0.05 + waveTime) * 2.5 * randomAmp;
                const wave2 = Math.sin(z * 0.03 + waveTime * 1.3) * 2.0 * randomAmp;
                const wave3 = Math.sin((x + z) * 0.02 + waveTime * 0.8) * 1.5 * randomAmp;

                oceanPositions.setZ(i, wave1 + wave2 + wave3);
            }
            oceanPositions.needsUpdate = true;
            ocean.geometry.computeVertexNormals();

            // Check if underwater
            const wasUnderwater = isUnderwater;
            isUnderwater = bird.position.y < 0;

            // Track time above water for gravity grace period
            if (!isUnderwater) {
                if (wasUnderwater) {
                    // Just breached the surface - reset timer
                    timeAboveWater = 0;
                } else {
                    // Still above water - increment timer (60 fps = ~0.0167s per frame)
                    timeAboveWater += 1/60;
                }
            } else {
                timeAboveWater = 0; // Reset when underwater
            }

            // Air time system (for jumping out of water)
            if (!isUnderwater) {
                // Above water - deplete air time
                airTime = Math.max(0, airTime - airTimeDepletionRate);
                document.getElementById('oxygenBar').style.display = 'block';

                // Force back underwater if air time runs out
                if (airTime <= 0) {
                    bird.position.y = -0.5; // Force underwater
                    airTime = 0;
                }
            } else {
                // Underwater - recover air time
                airTime = Math.min(maxAirTime, airTime + airTimeRecoveryRate);
                if (airTime >= maxAirTime) {
                    document.getElementById('oxygenBar').style.display = 'none';
                }
            }

            // Update air time bar
            document.getElementById('oxygenFill').style.width = airTime + '%';

            // Hunger system - passive depletion
            hunger = Math.max(0, hunger - hungerDepletionRate);

            // Hunger cost from boosting
            if (keys[' '] || keys['Space']) {
                hunger = Math.max(0, hunger - boostHungerCost);
            }

            // Update hunger bar
            document.getElementById('hungerFill').style.width = hunger + '%';

            // Death from starvation
            if (hunger <= 0) {
                bird.position.set(0, -5, 0);
                birdPitch = 0;
                birdYaw = 0;
                hunger = maxHunger;
                airTime = maxAirTime;
                const fishLost = Math.floor(caughtFishCount / 2);
                caughtFishCount -= fishLost;
                resetAllEnemies(); // Reset all enemies to safe positions
                console.log("Starved! Lost " + fishLost + " fish!");
            }

            // Update underwater overlay and fog
            const overlay = document.getElementById('underwaterOverlay');
            if (isUnderwater) {
                overlay.style.opacity = '0.3'; // Less dark overlay
                // Better underwater visibility!
                scene.fog.density = 0.015; // Much less fog - can see further
                scene.fog.color.setHex(0x004466); // Dark blue underwater fog
                scene.background.setHex(0x005577); // Lighter underwater background
            } else {
                overlay.style.opacity = '0';
                // Clear fog above water
                scene.fog.density = 0.001;
                scene.fog.color.setHex(0x5BA3D0); // Ocean blue sky
                scene.background.setHex(0x5BA3D0);
            }

            // Pitch controls (W = up, S = down)
            if (keys['w'] || keys['ArrowUp']) {
                birdPitch += pitchSpeed;
            }
            if (keys['s'] || keys['ArrowDown']) {
                birdPitch -= pitchSpeed;
            }

            // Apply pitch decay when no input (returns to level flight)
            if (!keys['w'] && !keys['ArrowUp'] && !keys['s'] && !keys['ArrowDown']) {
                birdPitch *= pitchDecay;
            }

            // Limit pitch angle
            birdPitch = Math.max(-0.8, Math.min(0.8, birdPitch));

            // Yaw controls (A = left, D = right) with banking
            if (keys['a'] || keys['ArrowLeft']) {
                birdYaw += yawSpeed;
                bankingAngle = Math.min(bankingAngle + 0.05, 0.6); // Tilt left (positive)
            } else if (keys['d'] || keys['ArrowRight']) {
                birdYaw -= yawSpeed;
                bankingAngle = Math.max(bankingAngle - 0.05, -0.6); // Tilt right (negative)
            } else {
                // Return to level when not turning
                bankingAngle *= 0.9;
            }

            // Speed mechanics based on pitch
            // Diving (negative pitch) increases speed
            // Climbing (positive pitch) decreases speed
            const pitchSpeedEffect = -birdPitch * 0.015;
            forwardSpeed += pitchSpeedEffect;

            // Air resistance - gradually return to cruising speed when flying level
            // This prevents maintaining high dive speeds indefinitely
            const speedDifference = forwardSpeed - cruisingSpeed;
            const airResistance = speedDifference * 0.02; // 2% drag toward cruising speed
            forwardSpeed -= airResistance;

            // Speed boost with space
            let currentSpeed = forwardSpeed;
            if (keys[' '] || keys['Space']) {
                currentSpeed *= 1.8;
            }

            // Much faster underwater!
            if (isUnderwater) {
                currentSpeed *= 2.5; // 150% speed INCREASE underwater
            }

            // Clamp speed
            forwardSpeed = Math.max(minSpeed, Math.min(maxSpeed, forwardSpeed));
            currentSpeed = Math.max(minSpeed, Math.min(maxSpeed * 1.8, currentSpeed));

            // Calculate movement based on pitch and yaw
            const pitchCos = Math.cos(birdPitch);
            const pitchSin = Math.sin(birdPitch);

            // Move bird in 3D space based on orientation
            bird.position.x += Math.sin(birdYaw) * pitchCos * currentSpeed;
            bird.position.z += Math.cos(birdYaw) * pitchCos * currentSpeed;
            bird.position.y += pitchSin * currentSpeed;

            // Add gravity when above water (but only after grace period)!
            if (!isUnderwater && timeAboveWater > GRAVITY_GRACE_PERIOD) {
                bird.position.y -= 0.15; // Gravity pulls swordfish down
            }

            // Map boundary - keep bird within ocean area
            if (Math.abs(bird.position.x) > MAP_SIZE) {
                bird.position.x = Math.sign(bird.position.x) * MAP_SIZE;
                birdYaw += Math.PI; // Turn around
            }
            if (Math.abs(bird.position.z) > MAP_SIZE) {
                bird.position.z = Math.sign(bird.position.z) * MAP_SIZE;
                birdYaw += Math.PI; // Turn around
            }

            // Height limits
            if (bird.position.y > 80) {
                bird.position.y = 80;
                birdPitch = Math.min(birdPitch, 0);
            }

            // Ocean floor limit when diving (deep ocean)
            if (bird.position.y < -78) {
                bird.position.y = -78;
                birdPitch = Math.max(birdPitch, 0);
            }

            // Calculate actual velocity to determine visual pitch
            const actualVelocity = bird.position.clone().sub(previousPosition);
            const horizontalSpeed = Math.sqrt(actualVelocity.x * actualVelocity.x + actualVelocity.z * actualVelocity.z);
            const verticalSpeed = actualVelocity.y;

            // Calculate the actual flight path angle based on real velocity
            // This ensures the bird visually points in the direction it's actually moving
            let visualPitch = birdPitch;
            if (horizontalSpeed > 0.001) { // Avoid division by zero
                visualPitch = Math.atan2(verticalSpeed, horizontalSpeed);
            }

            // Update bird rotation with actual flight direction
            bird.rotation.y = birdYaw;
            bird.rotation.x = -visualPitch; // Use actual flight path angle
            bird.rotation.z = bankingAngle; // Enhanced banking effect when turning

            // Store current position for next frame's velocity calculation
            previousPosition.copy(bird.position);

            // Animate swordfish fins based on speed
            wingFlap += 0.1 + currentSpeed * 0.2;
            const flapAmount = 0.15 + currentSpeed * 0.1;
            leftWing.rotation.z = Math.sin(wingFlap) * flapAmount + Math.PI / 2.5;
            rightWing.rotation.z = -Math.sin(wingFlap) * flapAmount - Math.PI / 2.5;

            // Update motion trail
            trailIndex = (trailIndex + 1) % trailLength;
            trailPoints[trailIndex].copy(bird.position);
            trail.geometry.setFromPoints(trailPoints);
            trail.geometry.attributes.position.needsUpdate = true;

            // Smoothly decay mouse look offset when not looking
            if (!isMouseLooking && Math.abs(mouseLookYawOffset) > 0.01) {
                mouseLookYawOffset *= 0.85;
            }

            // Camera system - toggle between first-person and third-person
            if (isFirstPerson) {
                // First-person camera positioned at bird's head
                const headOffset = new THREE.Vector3(0, 0.5, 0.6); // Position at head
                headOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), -birdPitch); // Apply pitch rotation
                headOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), birdYaw); // Apply yaw rotation

                camera.position.copy(bird.position.clone().add(headOffset));

                // Camera looks in the direction modified by mouse look
                const lookYaw = birdYaw + mouseLookYawOffset;
                const lookDirection = new THREE.Vector3(
                    Math.sin(lookYaw) * Math.cos(birdPitch),
                    Math.sin(birdPitch),
                    Math.cos(lookYaw) * Math.cos(birdPitch)
                );
                const lookTarget = camera.position.clone().add(lookDirection.multiplyScalar(10));
                camera.lookAt(lookTarget);
            } else {
                // Third-person camera follows bird from behind with mouse look
                const cameraDistance = 10 + currentSpeed * 8;
                const cameraHeight = 3 - birdPitch * 8;
                // Apply mouse look offset to camera yaw
                const cameraYaw = birdYaw + mouseLookYawOffset;
                const cameraOffset = new THREE.Vector3(
                    Math.sin(cameraYaw) * -cameraDistance,
                    cameraHeight,
                    Math.cos(cameraYaw) * -cameraDistance
                );
                camera.position.lerp(bird.position.clone().add(cameraOffset), 0.08);
                camera.lookAt(bird.position);
            }

            // Move clouds slowly for parallax effect
            clouds.forEach((cloud, index) => {
                cloud.position.x += 0.008;
                cloud.position.z += Math.sin(index * 0.5) * 0.002;
                if (cloud.position.x > 150) {
                    cloud.position.x = -150;
                }
            });

            // Update fish behavior - OPTIMIZED BOID/FLOCKING ALGORITHM
            const CATCH_DISTANCE = 2.0;
            const PERCEPTION_RADIUS = 15.0; // Reduced for better performance
            const FLEE_RADIUS = 35.0; // Fish can see you from VERY far away!
            const SHARK_ATTRACTION_RADIUS = 20.0; // Stronger shark attraction
            const SEPARATION_DISTANCE = 1.5; // Hitbox distance - fish can't overlap

            // Staggered updates - only update a batch of fish per frame for performance
            const startIndex = fishUpdateOffset;
            const endIndex = Math.min(startIndex + FISH_UPDATE_BATCH_SIZE, fish.length);

            for (let i = fish.length - 1; i >= 0; i--) {
                const fishObj = fish[i];
                if (fishObj.userData.isCaught) continue;

                fishObj.userData.swimTime += 0.05;

                // Only do expensive boid calculations for fish in current batch
                const shouldUpdateBoid = (i >= startIndex && i < endIndex);

                // Calculate distance to player
                const dx = bird.position.x - fishObj.position.x;
                const dz = bird.position.z - fishObj.position.z;
                const dy = bird.position.y - fishObj.position.y;
                const distanceToBird = Math.sqrt(dx * dx + dz * dz + dy * dy);

                // Only calculate expensive boid forces for fish in current update batch
                if (shouldUpdateBoid) {
                    // BOID FORCES
                    const cohesion = new THREE.Vector3(0, 0, 0); // Move towards center of nearby fish
                    const separation = new THREE.Vector3(0, 0, 0); // Avoid crowding
                    const alignment = new THREE.Vector3(0, 0, 0); // Match velocity of nearby fish
                    const fleeForce = new THREE.Vector3(0, 0, 0); // Flee from player
                    const sharkAttraction = new THREE.Vector3(0, 0, 0); // Move towards nearest shark

                    let nearbyCount = 0;

                    // Check nearby fish for flocking behavior
                    for (let j = 0; j < fish.length; j++) {
                        if (i === j || fish[j].userData.isCaught) continue;

                        const other = fish[j];
                        const dist = fishObj.position.distanceTo(other.position);

                        if (dist < PERCEPTION_RADIUS) {
                            // Cohesion - move towards center of mass
                            cohesion.add(other.position);

                            // Alignment - match velocity
                            alignment.add(other.userData.velocity);

                            nearbyCount++;

                            // Separation - STRONG collision avoidance using hitbox radius
                            const minDistance = fishObj.userData.radius + other.userData.radius;
                            if (dist < SEPARATION_DISTANCE && dist > 0) {
                                const diff = new THREE.Vector3().subVectors(fishObj.position, other.position);
                                // Much stronger separation force when fish are too close (collision avoidance)
                                const separationStrength = dist < minDistance ? 0.5 : 0.15;
                                diff.divideScalar(dist); // Weight by distance
                                diff.multiplyScalar(separationStrength);
                                separation.add(diff);
                            }
                        }
                    }

                    if (nearbyCount > 0) {
                        cohesion.divideScalar(nearbyCount);
                        cohesion.sub(fishObj.position);
                        cohesion.normalize().multiplyScalar(0.08); // VERY strong cohesion - fish really stick together!

                        alignment.divideScalar(nearbyCount);
                        alignment.normalize().multiplyScalar(0.04); // Strong alignment for synchronized swimming

                        // Separation is already scaled per-fish above, just normalize the accumulated force
                        if (separation.length() > 0) {
                            separation.normalize().multiplyScalar(0.2); // Strong separation to prevent overlap
                        }
                    }

                    // Flee from player when close
                    if (distanceToBird < FLEE_RADIUS) {
                        fleeForce.set(-dx, -dy, -dz);
                        // Flee force gets stronger as you get closer
                        const fleeStrength = 0.3 * (1 - distanceToBird / FLEE_RADIUS);
                        fleeForce.normalize().multiplyScalar(0.3 + fleeStrength); // REALLY strong flee
                    }

                    // Attraction to nearest shark
                    let nearestSharkDist = Infinity;
                    let nearestShark = null;
                    for (let s = 0; s < sharks.length; s++) {
                        const sharkDist = fishObj.position.distanceTo(sharks[s].position);
                        if (sharkDist < nearestSharkDist && sharkDist < SHARK_ATTRACTION_RADIUS) {
                            nearestSharkDist = sharkDist;
                            nearestShark = sharks[s];
                        }
                    }

                    if (nearestShark) {
                        sharkAttraction.subVectors(nearestShark.position, fishObj.position);
                        sharkAttraction.normalize().multiplyScalar(0.04); // Stronger shark attraction
                    }

                    // Apply all forces to velocity
                    fishObj.userData.velocity.add(cohesion);
                    fishObj.userData.velocity.add(separation);
                    fishObj.userData.velocity.add(alignment);
                    fishObj.userData.velocity.add(fleeForce);
                    fishObj.userData.velocity.add(sharkAttraction);
                }

                // Limit speed
                const speed = fishObj.userData.velocity.length();
                if (speed > fishObj.userData.maxSpeed) {
                    fishObj.userData.velocity.normalize().multiplyScalar(fishObj.userData.maxSpeed);
                }

                // Apply velocity to position
                fishObj.position.add(fishObj.userData.velocity);

                // Keep fish underwater in deep ocean (between -75 and -2 meters)
                if (fishObj.position.y > -2) {
                    fishObj.position.y = -2;
                    fishObj.userData.verticalAngle = -Math.abs(fishObj.userData.verticalAngle);
                }
                if (fishObj.position.y < -75) {
                    fishObj.position.y = -75;
                    fishObj.userData.verticalAngle = Math.abs(fishObj.userData.verticalAngle);
                }

                // Keep fish within map boundaries
                const fishBoundary = MAP_SIZE - 50;
                if (Math.abs(fishObj.position.x) > fishBoundary) {
                    fishObj.position.x = Math.sign(fishObj.position.x) * fishBoundary;
                    fishObj.userData.wanderAngle = Math.PI - fishObj.userData.wanderAngle;
                }
                if (Math.abs(fishObj.position.z) > fishBoundary) {
                    fishObj.position.z = Math.sign(fishObj.position.z) * fishBoundary;
                    fishObj.userData.wanderAngle = -fishObj.userData.wanderAngle;
                }

                // Update fish rotation to face velocity direction
                if (fishObj.userData.velocity.length() > 0.01) {
                    const velocityAngle = Math.atan2(fishObj.userData.velocity.x, fishObj.userData.velocity.z);
                    const verticalAngle = Math.atan2(fishObj.userData.velocity.y,
                        Math.sqrt(fishObj.userData.velocity.x ** 2 + fishObj.userData.velocity.z ** 2));
                    fishObj.rotation.y = velocityAngle;
                    fishObj.rotation.x = -verticalAngle;
                }

                // Animate fish tail and fins
                const tailWag = Math.sin(fishObj.userData.swimTime * 5) * 0.3;
                if (fishObj.children[6]) { // Tail fin
                    fishObj.children[6].rotation.y = tailWag;
                }

                // Check if caught (only when bird is underwater)
                if (distanceToBird < CATCH_DISTANCE && isUnderwater) {
                    fishObj.userData.isCaught = true;
                    scene.remove(fishObj);
                    fish.splice(i, 1);
                    caughtFishCount++;

                    // Increase hunger when eating fish
                    hunger = Math.min(maxHunger, hunger + fishHungerGain);

                    // Respawn a new fish in a random location
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 450;
                    const newFish = createFish(
                        Math.cos(angle) * distance,
                        Math.sin(angle) * distance
                    );
                    fish.push(newFish);
                    scene.add(newFish);
                }
            }

            // Update batch offset for next frame (cycle through all fish)
            fishUpdateOffset += FISH_UPDATE_BATCH_SIZE;
            if (fishUpdateOffset >= fish.length) {
                fishUpdateOffset = 0;
            }

            // Update shark behavior
            const SHARK_ATTACK_DISTANCE = 3.5; // Distance at which shark attacks
            const SHARK_CHASE_DISTANCE = 60; // Sharks can see you from VERY far away!

            for (let i = 0; i < sharks.length; i++) {
                const shark = sharks[i];

                // Animate shark swimming
                shark.userData.swimTime += 0.03;

                // Calculate distance to bird
                const dx = bird.position.x - shark.position.x;
                const dz = bird.position.z - shark.position.z;
                const dy = bird.position.y - shark.position.y;
                const distanceToBird = Math.sqrt(dx * dx + dz * dz + dy * dy);

                // Shark AI: patrol or chase (ONLY chase when player is underwater - sharks can't see above water!)
                if (isUnderwater && bird.position.y < 0 && distanceToBird < SHARK_CHASE_DISTANCE) {
                    // Chase the bird!
                    const chaseAngle = Math.atan2(dx, dz);
                    const verticalChase = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));

                    shark.userData.patrolAngle = chaseAngle;
                    shark.userData.verticalAngle = verticalChase;

                    // Sharks swim faster when chasing - scary!
                    const chaseSpeed = shark.userData.swimSpeed * 1.4;
                    shark.position.x += Math.sin(chaseAngle) * chaseSpeed;
                    shark.position.z += Math.cos(chaseAngle) * chaseSpeed;
                    shark.position.y += Math.sin(verticalChase) * chaseSpeed * 0.5;
                } else {
                    // Normal patrol behavior
                    shark.userData.patrolAngle += (Math.random() - 0.5) * 0.05;
                    shark.userData.verticalAngle += (Math.random() - 0.5) * 0.02;
                    shark.userData.verticalAngle = Math.max(-0.2, Math.min(0.2, shark.userData.verticalAngle));

                    shark.position.x += Math.sin(shark.userData.patrolAngle) * shark.userData.swimSpeed;
                    shark.position.z += Math.cos(shark.userData.patrolAngle) * shark.userData.swimSpeed;
                    shark.position.y += Math.sin(shark.userData.verticalAngle) * shark.userData.swimSpeed * 0.3;
                }

                // Keep sharks underwater in deep ocean (between -75 and -3 meters)
                if (shark.position.y > -3) {
                    shark.position.y = -3;
                    shark.userData.verticalAngle = -Math.abs(shark.userData.verticalAngle);
                }
                if (shark.position.y < -75) {
                    shark.position.y = -75;
                    shark.userData.verticalAngle = Math.abs(shark.userData.verticalAngle);
                }

                // Keep sharks within map boundaries
                const sharkBoundary = MAP_SIZE - 50;
                if (Math.abs(shark.position.x) > sharkBoundary) {
                    shark.position.x = Math.sign(shark.position.x) * sharkBoundary;
                    shark.userData.patrolAngle = Math.PI - shark.userData.patrolAngle;
                }
                if (Math.abs(shark.position.z) > sharkBoundary) {
                    shark.position.z = Math.sign(shark.position.z) * sharkBoundary;
                    shark.userData.patrolAngle = -shark.userData.patrolAngle;
                }

                // Update shark rotation to face movement direction
                shark.rotation.y = shark.userData.patrolAngle;
                shark.rotation.x = shark.userData.verticalAngle;

                // Animate shark tail
                const tailWag = Math.sin(shark.userData.swimTime * 4) * 0.2;
                if (shark.children[7]) { // Tail fin
                    shark.children[7].rotation.y = tailWag;
                }

                // Sharks eat fish
                const SHARK_EAT_DISTANCE = 2.5;
                for (let j = fish.length - 1; j >= 0; j--) {
                    const fishObj = fish[j];
                    if (fishObj.userData.isCaught) continue;

                    const fishDist = shark.position.distanceTo(fishObj.position);
                    if (fishDist < SHARK_EAT_DISTANCE) {
                        // Shark eats the fish
                        scene.remove(fishObj);
                        fish.splice(j, 1);

                        // Respawn a new fish in a random location
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 450;
                        const newFish = createFish(
                            Math.cos(angle) * distance,
                            Math.sin(angle) * distance
                        );
                        fish.push(newFish);
                        scene.add(newFish);
                        break; // Shark only eats one fish per frame
                    }
                }

                // Check if shark caught the swordfish (game over)
                if (distanceToBird < SHARK_ATTACK_DISTANCE && isUnderwater) {
                    // Shark attack! Reset position and lose some fish
                    bird.position.set(0, -5, 0);
                    birdPitch = 0;
                    birdYaw = 0;
                    airTime = maxAirTime;
                    hunger = maxHunger; // Reset hunger to max on death

                    // Lose half of caught fish
                    const fishLost = Math.floor(caughtFishCount / 2);
                    caughtFishCount -= fishLost;

                    resetAllEnemies(); // Reset all enemies to safe positions

                    // Visual feedback
                    console.log("Shark attack! Lost " + fishLost + " fish!");
                }
            }

            // Shark respawning - add new sharks periodically to maintain population
            sharkSpawnTimer++;
            if (sharkSpawnTimer >= sharkSpawnInterval && sharks.length < 20) {
                sharkSpawnTimer = 0;

                // Ensure sharks don't spawn within chase distance (60m) of player
                let spawnX, spawnZ, distanceToPlayer;
                const MIN_SPAWN_DISTANCE = 100; // Spawn at least 100m away from player

                do {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = MIN_SPAWN_DISTANCE + Math.random() * 350;
                    spawnX = Math.cos(angle) * distance;
                    spawnZ = Math.sin(angle) * distance;

                    // Calculate distance from player
                    const dx = bird.position.x - spawnX;
                    const dz = bird.position.z - spawnZ;
                    distanceToPlayer = Math.sqrt(dx * dx + dz * dz);
                } while (distanceToPlayer < MIN_SPAWN_DISTANCE);

                const newShark = createShark(spawnX, spawnZ);
                const spawnY = -10 - Math.random() * 50;
                newShark.position.y = spawnY;
                newShark.userData.spawnY = spawnY;
                sharks.push(newShark);
                scene.add(newShark);
            }

            // Update barracuda behavior - VERY aggressive chase AI!
            const BARRACUDA_ATTACK_DISTANCE = 3.0;
            const BARRACUDA_CHASE_DISTANCE = 80; // Chase from very far!
            const BARRACUDA_PROJECTILE_HIT_DISTANCE = 1.5;

            for (let i = barracudas.length - 1; i >= 0; i--) {
                const barracuda = barracudas[i];

                barracuda.userData.swimTime += 0.05;

                const dx = bird.position.x - barracuda.position.x;
                const dz = bird.position.z - barracuda.position.z;
                const dy = bird.position.y - barracuda.position.y;
                const distanceToBird = Math.sqrt(dx * dx + dz * dz + dy * dy);

                // Barracudas ALWAYS chase when player is in range (even above water!)
                if (distanceToBird < BARRACUDA_CHASE_DISTANCE) {
                    const chaseAngle = Math.atan2(dx, dz);
                    const verticalChase = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));

                    barracuda.userData.patrolAngle = chaseAngle;
                    barracuda.userData.verticalAngle = verticalChase;

                    // Barracudas are VERY fast chasers!
                    const chaseSpeed = barracuda.userData.swimSpeed * 1.6;
                    barracuda.position.x += Math.sin(chaseAngle) * chaseSpeed;
                    barracuda.position.z += Math.cos(chaseAngle) * chaseSpeed;
                    barracuda.position.y += Math.sin(verticalChase) * chaseSpeed * 0.6;
                } else {
                    // Patrol when out of range
                    barracuda.userData.patrolAngle += (Math.random() - 0.5) * 0.08;
                    barracuda.userData.verticalAngle += (Math.random() - 0.5) * 0.03;
                    barracuda.userData.verticalAngle = Math.max(-0.3, Math.min(0.3, barracuda.userData.verticalAngle));

                    barracuda.position.x += Math.sin(barracuda.userData.patrolAngle) * barracuda.userData.swimSpeed;
                    barracuda.position.z += Math.cos(barracuda.userData.patrolAngle) * barracuda.userData.swimSpeed;
                    barracuda.position.y += Math.sin(barracuda.userData.verticalAngle) * barracuda.userData.swimSpeed * 0.4;
                }

                // Keep barracudas underwater
                if (barracuda.position.y > -2) {
                    barracuda.position.y = -2;
                    barracuda.userData.verticalAngle = -Math.abs(barracuda.userData.verticalAngle);
                }
                if (barracuda.position.y < -75) {
                    barracuda.position.y = -75;
                    barracuda.userData.verticalAngle = Math.abs(barracuda.userData.verticalAngle);
                }

                // Keep within map boundaries
                const barracudaBoundary = MAP_SIZE - 50;
                if (Math.abs(barracuda.position.x) > barracudaBoundary) {
                    barracuda.position.x = Math.sign(barracuda.position.x) * barracudaBoundary;
                    barracuda.userData.patrolAngle = Math.PI - barracuda.userData.patrolAngle;
                }
                if (Math.abs(barracuda.position.z) > barracudaBoundary) {
                    barracuda.position.z = Math.sign(barracuda.position.z) * barracudaBoundary;
                    barracuda.userData.patrolAngle = -barracuda.userData.patrolAngle;
                }

                // Update rotation
                barracuda.rotation.y = barracuda.userData.patrolAngle;
                barracuda.rotation.x = barracuda.userData.verticalAngle;

                // Animate tail
                const tailWag = Math.sin(barracuda.userData.swimTime * 6) * 0.25;
                if (barracuda.children[6]) {
                    barracuda.children[6].rotation.y = tailWag;
                }

                // Check if barracuda attacks player
                if (distanceToBird < BARRACUDA_ATTACK_DISTANCE) {
                    bird.position.set(0, -5, 0);
                    birdPitch = 0;
                    birdYaw = 0;
                    airTime = maxAirTime;
                    hunger = maxHunger;

                    const fishLost = Math.floor(caughtFishCount / 3); // Lose 1/3 of fish
                    caughtFishCount -= fishLost;

                    resetAllEnemies(); // Reset all enemies to safe positions

                    console.log("Barracuda attack! Lost " + fishLost + " fish!");
                }

                // Check projectile hits on barracuda
                for (let p = projectiles.length - 1; p >= 0; p--) {
                    const projectile = projectiles[p];
                    const hitDist = barracuda.position.distanceTo(projectile.position);

                    if (hitDist < BARRACUDA_PROJECTILE_HIT_DISTANCE) {
                        // Hit the barracuda!
                        barracuda.userData.health -= 1;

                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(p, 1);

                        // Flash the barracuda red when hit
                        barracuda.children[0].material.emissiveIntensity = 0.8;
                        setTimeout(() => {
                            if (barracuda.children[0]) {
                                barracuda.children[0].material.emissiveIntensity = 0.2;
                            }
                        }, 100);

                        // Kill barracuda if health reaches 0
                        if (barracuda.userData.health <= 0) {
                            scene.remove(barracuda);
                            barracudas.splice(i, 1);
                            console.log("Barracuda defeated!");
                        }
                        break;
                    }
                }
            }

            // Update projectiles
            const currentTime = Date.now();
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];

                // Move projectile
                projectile.position.add(projectile.userData.velocity);

                // Rotate projectile for visual effect
                projectile.rotation.x += 0.2;
                projectile.rotation.y += 0.2;

                // Check if projectile hit a shark
                for (let s = 0; s < sharks.length; s++) {
                    const shark = sharks[s];
                    const hitDist = shark.position.distanceTo(projectile.position);

                    if (hitDist < 2.0) {
                        // Projectile hit shark - sharks are tougher, just scare them away
                        shark.position.x += (shark.position.x - bird.position.x) * 0.5;
                        shark.position.z += (shark.position.z - bird.position.z) * 0.5;

                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        break;
                    }
                }

                // Remove old projectiles
                if (currentTime - projectile.userData.createdAt > PROJECTILE_LIFETIME) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Remove projectiles that go out of bounds
                if (Math.abs(projectile.position.x) > MAP_SIZE ||
                    Math.abs(projectile.position.z) > MAP_SIZE ||
                    projectile.position.y < -80 || projectile.position.y > 100) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                }
            }

            // Animate kelp swaying
            kelpForest.forEach(kelp => {
                kelp.userData.swayOffset += 0.01 * kelp.userData.swaySpeed;
                const swayAmount = Math.sin(kelp.userData.swayOffset) * 0.1;
                kelp.rotation.z = swayAmount;
                kelp.rotation.x = Math.cos(kelp.userData.swayOffset * 0.7) * 0.05;
            });

            // Update stats with color coding
            const speedElement = document.getElementById('speed');
            const speedValue = currentSpeed.toFixed(3);
            speedElement.textContent = speedValue;

            // Color code speed
            if (currentSpeed > 0.5) {
                speedElement.className = 'speed-indicator high-speed';
            } else if (currentSpeed < 0.25) {
                speedElement.className = 'speed-indicator low-speed';
            } else {
                speedElement.className = 'speed-indicator';
            }

            document.getElementById('altitude').textContent = Math.round(bird.position.y);
            document.getElementById('pitch').textContent = Math.round(birdPitch * 57.3); // Convert to degrees
            document.getElementById('position').textContent =
                `${Math.round(bird.position.x)}, ${Math.round(bird.position.z)}`;
            document.getElementById('caughtFish').textContent = caughtFishCount;
            document.getElementById('hunger').textContent = Math.round(hunger);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>

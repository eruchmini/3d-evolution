<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bird Flying Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }

        #instructions h2 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        #instructions ul {
            list-style-position: inside;
            margin-left: 10px;
        }

        #instructions li {
            margin: 5px 0;
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            min-width: 200px;
        }

        #stats div {
            margin: 5px 0;
        }

        .speed-indicator {
            font-weight: bold;
        }

        .high-speed {
            color: #ff4444;
        }

        .low-speed {
            color: #44ff44;
        }

        #oxygenBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 3px;
            display: none;
        }

        #oxygenFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0099ff);
            border-radius: 12px;
            transition: width 0.3s ease;
        }

        #underwaterOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(0, 80, 120, 0.3) 0%, rgba(0, 40, 80, 0.6) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>üê¶ Ocean Diving Game</h2>
        <ul>
            <li><strong>W/‚Üë</strong> - Pitch up</li>
            <li><strong>S/‚Üì</strong> - Pitch down / Dive underwater</li>
            <li><strong>A/‚Üê</strong> - Turn left</li>
            <li><strong>D/‚Üí</strong> - Turn right</li>
            <li><strong>Space</strong> - Speed boost</li>
            <li><strong>F</strong> - Toggle 1st/3rd person view</li>
        </ul>
        <p style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
            Dive into the ocean to catch fish! Watch your oxygen bar underwater.
        </p>
    </div>

    <div id="stats">
        <div>Altitude: <span id="altitude">0</span>m</div>
        <div>Speed: <span id="speed" class="speed-indicator">0</span></div>
        <div>Pitch: <span id="pitch">0</span>¬∞</div>
        <div>Position: <span id="position">0, 0</span></div>
        <div>Fish Caught: <span id="caughtFish">0</span></div>
    </div>

    <div id="oxygenBar">
        <div id="oxygenFill"></div>
    </div>

    <div id="underwaterOverlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Ocean sky with gradient
        const skyColor = 0x5BA3D0; // Ocean blue sky
        const horizonColor = 0xffffff;
        scene.background = new THREE.Color(skyColor);
        scene.fog = new THREE.FogExp2(0x5BA3D0, 0.001);

        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xfff5e1, 1.2);
        directionalLight.position.set(100, 150, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // Add hemisphere light for better ambient lighting
        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.5);
        scene.add(hemisphereLight);

        // Create bird with improved materials
        const bird = new THREE.Group();

        // Bird body with better material
        const bodyGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        bodyGeometry.scale(1, 0.8, 1.2);
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF6B6B,
            metalness: 0.1,
            roughness: 0.6,
            emissive: 0x330000,
            emissiveIntensity: 0.1
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        bird.add(body);

        // Bird head
        const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const headMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF8C8C,
            metalness: 0.1,
            roughness: 0.6
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.set(0, 0.2, 0.6);
        head.castShadow = true;
        bird.add(head);

        // Bird eyes
        const eyeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
        const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.12, 0.25, 0.75);
        bird.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.12, 0.25, 0.75);
        bird.add(rightEye);

        // Bird beak
        const beakGeometry = new THREE.ConeGeometry(0.1, 0.35, 8);
        const beakMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            metalness: 0.3,
            roughness: 0.4
        });
        const beak = new THREE.Mesh(beakGeometry, beakMaterial);
        beak.position.set(0, 0.2, 0.9);
        beak.rotation.x = Math.PI / 2;
        bird.add(beak);

        // Enhanced wings
        const wingGeometry = new THREE.BoxGeometry(1.4, 0.08, 0.7);
        const wingMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF5252,
            metalness: 0.2,
            roughness: 0.5,
            emissive: 0x330000,
            emissiveIntensity: 0.1
        });
        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-0.8, 0, 0);
        leftWing.castShadow = true;
        bird.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(0.8, 0, 0);
        rightWing.castShadow = true;
        bird.add(rightWing);

        // Tail feathers
        const tailGeometry = new THREE.ConeGeometry(0.35, 0.7, 8);
        const tailMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF5252,
            metalness: 0.2,
            roughness: 0.5
        });
        const tail = new THREE.Mesh(tailGeometry, tailMaterial);
        tail.position.set(0, 0, -0.9);
        tail.rotation.x = Math.PI / 2;
        tail.castShadow = true;
        bird.add(tail);

        bird.position.set(0, 15, 0);
        scene.add(bird);

        // Motion trail
        const trailPoints = [];
        const trailLength = 20;
        for (let i = 0; i < trailLength; i++) {
            trailPoints.push(new THREE.Vector3(0, 15, 0));
        }
        const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
        const trailMaterial = new THREE.LineBasicMaterial({
            color: 0xFF6B6B,
            transparent: true,
            opacity: 0.3,
            linewidth: 2
        });
        const trail = new THREE.Line(trailGeometry, trailMaterial);
        scene.add(trail);

        // Ocean surface with animated waves
        const oceanGeometry = new THREE.PlaneGeometry(2000, 2000, 150, 150);
        const oceanMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            roughness: 0.4,
            metalness: 0.6,
            transparent: true,
            opacity: 0.9
        });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.y = 0;
        ocean.receiveShadow = true;

        // Store original positions for wave animation
        const oceanPositions = ocean.geometry.attributes.position;
        const originalPositions = new Float32Array(oceanPositions.count * 3);
        for (let i = 0; i < oceanPositions.count; i++) {
            originalPositions[i * 3] = oceanPositions.getX(i);
            originalPositions[i * 3 + 1] = oceanPositions.getY(i);
            originalPositions[i * 3 + 2] = oceanPositions.getZ(i);
        }

        scene.add(ocean);

        // Ocean floor
        const oceanFloorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        const oceanFloorMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B7355, // Sandy brown
            roughness: 0.95,
            metalness: 0.05
        });
        const oceanFloor = new THREE.Mesh(oceanFloorGeometry, oceanFloorMaterial);
        oceanFloor.rotation.x = -Math.PI / 2;
        oceanFloor.position.y = -15; // Ocean floor at -15m (shallow ocean)
        oceanFloor.receiveShadow = true;

        // Add variation to ocean floor for terrain effect
        const floorPositions = oceanFloor.geometry.attributes.position;
        for (let i = 0; i < floorPositions.count; i++) {
            const variation = Math.random() * 0.5 + Math.sin(i * 0.1) * 0.3;
            floorPositions.setZ(i, variation);
        }
        floorPositions.needsUpdate = true;
        oceanFloor.geometry.computeVertexNormals();

        scene.add(oceanFloor);

        // Create enhanced clouds
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.7,
                roughness: 1,
                metalness: 0
            });

            for (let i = 0; i < 7; i++) {
                const cloudPart = new THREE.Mesh(
                    new THREE.SphereGeometry(Math.random() * 2.5 + 1.5, 16, 16),
                    cloudMaterial
                );
                cloudPart.position.set(
                    Math.random() * 5 - 2.5,
                    Math.random() * 2 - 1,
                    Math.random() * 5 - 2.5
                );
                cloud.add(cloudPart);
            }

            cloud.position.set(x, y, z);
            return cloud;
        }

        // Add multiple clouds at various heights
        const clouds = [];
        for (let i = 0; i < 30; i++) {
            const cloud = createCloud(
                Math.random() * 300 - 150,
                Math.random() * 40 + 20,
                Math.random() * 300 - 150
            );
            clouds.push(cloud);
            scene.add(cloud);
        }

        // Trees removed - now ocean environment

        // Grass removed - ocean environment

        // Mountains removed - open ocean environment
        const MAP_SIZE = 500; // Larger ocean area

        // Create fish
        function createFish(x, z) {
            const fish = new THREE.Group();

            // Fish colors - variety of ocean fish
            const fishColors = [
                0xFF6B35, // Orange
                0xFFD23F, // Yellow
                0x00A6ED, // Blue
                0xFF006E, // Pink
                0x3BCEAC, // Teal
                0xA463F2, // Purple
            ];
            const fishColor = fishColors[Math.floor(Math.random() * fishColors.length)];

            // Fish body (elongated sphere)
            const bodyGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            bodyGeometry.scale(1, 0.9, 1.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: fishColor,
                roughness: 0.4,
                metalness: 0.5,
                emissive: fishColor,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            fish.add(body);

            // Fish eyes
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeWhiteMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
            leftEye.position.set(-0.15, 0.12, 0.35);
            fish.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeWhiteMaterial);
            rightEye.position.set(0.15, 0.12, 0.35);
            fish.add(rightEye);

            // Eye pupils
            const pupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.15, 0.12, 0.41);
            fish.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.15, 0.12, 0.41);
            fish.add(rightPupil);

            // Dorsal fin (top fin)
            const dorsalFinGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
            const finMaterial = new THREE.MeshStandardMaterial({
                color: fishColor,
                roughness: 0.5,
                metalness: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
            dorsalFin.position.set(0, 0.35, 0);
            dorsalFin.rotation.x = Math.PI;
            fish.add(dorsalFin);

            // Side fins
            const sideFinsGeometry = new THREE.ConeGeometry(0.12, 0.3, 8);
            const leftFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            leftFin.position.set(-0.25, -0.05, 0.1);
            leftFin.rotation.z = Math.PI / 3;
            fish.add(leftFin);
            const rightFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            rightFin.position.set(0.25, -0.05, 0.1);
            rightFin.rotation.z = -Math.PI / 3;
            fish.add(rightFin);

            // Tail fin
            const tailGeometry = new THREE.ConeGeometry(0.25, 0.5, 8);
            const tail = new THREE.Mesh(tailGeometry, finMaterial);
            tail.position.set(0, 0, -0.5);
            tail.rotation.x = -Math.PI / 2;
            fish.add(tail);

            // Start fish at various depths in shallower ocean
            const depth = -2 - Math.random() * 10; // Between -2 and -12 meters
            fish.position.set(x, depth, z);

            // Add custom properties for behavior
            fish.userData.velocity = new THREE.Vector3(0, 0, 0);
            fish.userData.swimSpeed = 0.08;
            fish.userData.wanderSpeed = 0.03;
            fish.userData.wanderAngle = Math.random() * Math.PI * 2;
            fish.userData.verticalAngle = (Math.random() - 0.5) * 0.5;
            fish.userData.isCaught = false;
            fish.userData.swimTime = Math.random() * 100;

            return fish;
        }

        // Spawn fish across the ocean
        const fish = [];
        const NUM_FISH = 120; // Increased from 40 for more underwater life
        for (let i = 0; i < NUM_FISH; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 400;
            const newFish = createFish(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            fish.push(newFish);
            scene.add(newFish);
        }

        let caughtFishCount = 0;

        // Create sharks
        function createShark(x, z) {
            const shark = new THREE.Group();

            // Shark body (elongated and larger)
            const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            bodyGeometry.scale(1, 0.8, 2.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568, // Dark gray
                roughness: 0.6,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            shark.add(body);

            // Shark underbelly (lighter)
            const bellyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            bellyGeometry.scale(1, 0.6, 2.2);
            const bellyMaterial = new THREE.MeshStandardMaterial({
                color: 0xE5E7EB, // Light gray
                roughness: 0.6,
                metalness: 0.2
            });
            const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
            belly.position.y = -0.2;
            shark.add(belly);

            // Shark head/snout
            const snoutGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const snoutMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568,
                roughness: 0.6,
                metalness: 0.3
            });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0, 0, 1.5);
            snout.rotation.x = Math.PI / 2;
            shark.add(snout);

            // Shark eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.25, 0.2, 1.1);
            shark.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.25, 0.2, 1.1);
            shark.add(rightEye);

            // Dorsal fin (top)
            const dorsalFinGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0x4A5568,
                roughness: 0.6,
                metalness: 0.3
            });
            const dorsalFin = new THREE.Mesh(dorsalFinGeometry, finMaterial);
            dorsalFin.position.set(0, 0.6, -0.2);
            dorsalFin.rotation.x = Math.PI;
            shark.add(dorsalFin);

            // Side fins
            const sideFinsGeometry = new THREE.ConeGeometry(0.25, 0.6, 8);
            const leftFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            leftFin.position.set(-0.5, -0.1, 0.3);
            leftFin.rotation.z = Math.PI / 2.5;
            shark.add(leftFin);
            const rightFin = new THREE.Mesh(sideFinsGeometry, finMaterial);
            rightFin.position.set(0.5, -0.1, 0.3);
            rightFin.rotation.z = -Math.PI / 2.5;
            shark.add(rightFin);

            // Tail fin
            const tailGeometry = new THREE.ConeGeometry(0.4, 1.0, 8);
            const tail = new THREE.Mesh(tailGeometry, finMaterial);
            tail.position.set(0, 0.2, -1.5);
            tail.rotation.x = -Math.PI / 2;
            shark.add(tail);

            shark.position.set(x, -8, z); // Patrol at mid-depth

            // Add custom properties for behavior
            shark.userData.velocity = new THREE.Vector3(0, 0, 0);
            shark.userData.swimSpeed = 0.15;
            shark.userData.patrolAngle = Math.random() * Math.PI * 2;
            shark.userData.verticalAngle = 0;
            shark.userData.swimTime = Math.random() * 100;
            shark.userData.isShark = true;

            return shark;
        }

        // Spawn a few sharks
        const sharks = [];
        const NUM_SHARKS = 4; // Just a couple of sharks
        for (let i = 0; i < NUM_SHARKS; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 300 + 100; // Keep them spread out
            const newShark = createShark(
                Math.cos(angle) * distance,
                Math.sin(angle) * distance
            );
            sharks.push(newShark);
            scene.add(newShark);
        }

        // Camera setup
        camera.position.set(0, 17, -10);
        camera.lookAt(bird.position);

        // Game state with momentum system
        const keys = {};
        let birdYaw = 0; // Horizontal rotation (left/right)
        let birdPitch = 0; // Vertical rotation (up/down)
        let forwardSpeed = 0.3; // Current forward speed
        const minSpeed = 0.15;
        const maxSpeed = 0.8;
        const cruisingSpeed = 0.3; // Natural cruising speed when flying level
        const pitchSpeed = 0.025; // How fast pitch changes
        const yawSpeed = 0.03; // How fast yaw changes
        const pitchDecay = 0.92; // How quickly pitch returns to neutral
        let wingFlap = 0;
        let trailIndex = 0;
        let bankingAngle = 0; // Current tilt angle when turning
        let isFirstPerson = true; // Camera mode: true = first-person, false = third-person
        let previousPosition = new THREE.Vector3(0, 15, 0); // Track previous position for velocity calculation

        // Underwater / diving mechanics
        let isUnderwater = false;
        let oxygen = 100; // Oxygen level (0-100)
        const maxOxygen = 100;
        const oxygenDepletionRate = 0.12; // Per frame (reduced from 0.3 for longer breath)
        const oxygenRecoveryRate = 1.5; // Per frame when above water (faster recovery)
        let waveTime = 0; // For wave animation

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;

            // Toggle camera mode with F key
            if (e.key === 'f' || e.key === 'F') {
                isFirstPerson = !isFirstPerson;
                console.log('Camera mode:', isFirstPerson ? 'First Person' : 'Third Person');
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop with momentum-based physics
        function animate() {
            requestAnimationFrame(animate);

            // Animate ocean waves
            waveTime += 0.02;
            for (let i = 0; i < oceanPositions.count; i++) {
                const x = originalPositions[i * 3];
                const y = originalPositions[i * 3 + 1];
                const z = originalPositions[i * 3 + 2];

                // Create wave pattern
                const wave1 = Math.sin(x * 0.05 + waveTime) * 0.8;
                const wave2 = Math.sin(z * 0.03 + waveTime * 1.3) * 0.6;
                const wave3 = Math.sin((x + z) * 0.02 + waveTime * 0.8) * 0.5;

                oceanPositions.setZ(i, wave1 + wave2 + wave3);
            }
            oceanPositions.needsUpdate = true;
            ocean.geometry.computeVertexNormals();

            // Check if underwater
            isUnderwater = bird.position.y < 0;

            // Oxygen system
            if (isUnderwater) {
                oxygen = Math.max(0, oxygen - oxygenDepletionRate);
                document.getElementById('oxygenBar').style.display = 'block';

                // Death if oxygen runs out
                if (oxygen <= 0) {
                    bird.position.y = 0.5; // Force surface
                    oxygen = 0;
                }
            } else {
                oxygen = Math.min(maxOxygen, oxygen + oxygenRecoveryRate);
                if (oxygen >= maxOxygen) {
                    document.getElementById('oxygenBar').style.display = 'none';
                }
            }

            // Update oxygen bar
            document.getElementById('oxygenFill').style.width = oxygen + '%';

            // Update underwater overlay and fog
            const overlay = document.getElementById('underwaterOverlay');
            if (isUnderwater) {
                overlay.style.opacity = '0.5';
                // Underwater fog for limited visibility
                scene.fog.density = 0.08; // Much denser fog underwater
                scene.fog.color.setHex(0x004466); // Dark blue underwater fog
                scene.background.setHex(0x003355); // Dark blue underwater background
            } else {
                overlay.style.opacity = '0';
                // Clear fog above water
                scene.fog.density = 0.001;
                scene.fog.color.setHex(0x5BA3D0); // Ocean blue sky
                scene.background.setHex(0x5BA3D0);
            }

            // Pitch controls (W = up, S = down)
            if (keys['w'] || keys['ArrowUp']) {
                birdPitch += pitchSpeed;
            }
            if (keys['s'] || keys['ArrowDown']) {
                birdPitch -= pitchSpeed;
            }

            // Apply pitch decay when no input (returns to level flight)
            if (!keys['w'] && !keys['ArrowUp'] && !keys['s'] && !keys['ArrowDown']) {
                birdPitch *= pitchDecay;
            }

            // Limit pitch angle
            birdPitch = Math.max(-0.8, Math.min(0.8, birdPitch));

            // Yaw controls (A = left, D = right) with banking
            if (keys['a'] || keys['ArrowLeft']) {
                birdYaw += yawSpeed;
                bankingAngle = Math.min(bankingAngle + 0.05, 0.6); // Tilt left (positive)
            } else if (keys['d'] || keys['ArrowRight']) {
                birdYaw -= yawSpeed;
                bankingAngle = Math.max(bankingAngle - 0.05, -0.6); // Tilt right (negative)
            } else {
                // Return to level when not turning
                bankingAngle *= 0.9;
            }

            // Speed mechanics based on pitch
            // Diving (negative pitch) increases speed
            // Climbing (positive pitch) decreases speed
            const pitchSpeedEffect = -birdPitch * 0.015;
            forwardSpeed += pitchSpeedEffect;

            // Air resistance - gradually return to cruising speed when flying level
            // This prevents maintaining high dive speeds indefinitely
            const speedDifference = forwardSpeed - cruisingSpeed;
            const airResistance = speedDifference * 0.02; // 2% drag toward cruising speed
            forwardSpeed -= airResistance;

            // Speed boost with space
            let currentSpeed = forwardSpeed;
            if (keys[' '] || keys['Space']) {
                currentSpeed *= 1.8;
            }

            // Reduce speed when underwater
            if (isUnderwater) {
                currentSpeed *= 0.5; // 50% speed reduction underwater
            }

            // Clamp speed
            forwardSpeed = Math.max(minSpeed, Math.min(maxSpeed, forwardSpeed));
            currentSpeed = Math.max(minSpeed, Math.min(maxSpeed * 1.8, currentSpeed));

            // Calculate movement based on pitch and yaw
            const pitchCos = Math.cos(birdPitch);
            const pitchSin = Math.sin(birdPitch);

            // Move bird in 3D space based on orientation
            bird.position.x += Math.sin(birdYaw) * pitchCos * currentSpeed;
            bird.position.z += Math.cos(birdYaw) * pitchCos * currentSpeed;
            bird.position.y += pitchSin * currentSpeed;

            // Map boundary - keep bird within ocean area
            if (Math.abs(bird.position.x) > MAP_SIZE) {
                bird.position.x = Math.sign(bird.position.x) * MAP_SIZE;
                birdYaw += Math.PI; // Turn around
            }
            if (Math.abs(bird.position.z) > MAP_SIZE) {
                bird.position.z = Math.sign(bird.position.z) * MAP_SIZE;
                birdYaw += Math.PI; // Turn around
            }

            // Height limits
            if (bird.position.y > 80) {
                bird.position.y = 80;
                birdPitch = Math.min(birdPitch, 0);
            }

            // Ocean floor limit when diving (shallow ocean)
            if (bird.position.y < -14) {
                bird.position.y = -14;
                birdPitch = Math.max(birdPitch, 0);
            }

            // Calculate actual velocity to determine visual pitch
            const actualVelocity = bird.position.clone().sub(previousPosition);
            const horizontalSpeed = Math.sqrt(actualVelocity.x * actualVelocity.x + actualVelocity.z * actualVelocity.z);
            const verticalSpeed = actualVelocity.y;

            // Calculate the actual flight path angle based on real velocity
            // This ensures the bird visually points in the direction it's actually moving
            let visualPitch = birdPitch;
            if (horizontalSpeed > 0.001) { // Avoid division by zero
                visualPitch = Math.atan2(verticalSpeed, horizontalSpeed);
            }

            // Update bird rotation with actual flight direction
            bird.rotation.y = birdYaw;
            bird.rotation.x = -visualPitch; // Use actual flight path angle
            bird.rotation.z = bankingAngle; // Enhanced banking effect when turning

            // Store current position for next frame's velocity calculation
            previousPosition.copy(bird.position);

            // Dynamic wing flapping based on speed
            wingFlap += 0.15 + currentSpeed * 0.3;
            const flapAmount = 0.25 + currentSpeed * 0.15;
            leftWing.rotation.z = Math.sin(wingFlap) * flapAmount;
            rightWing.rotation.z = -Math.sin(wingFlap) * flapAmount;

            // Update motion trail
            trailIndex = (trailIndex + 1) % trailLength;
            trailPoints[trailIndex].copy(bird.position);
            trail.geometry.setFromPoints(trailPoints);
            trail.geometry.attributes.position.needsUpdate = true;

            // Camera system - toggle between first-person and third-person
            if (isFirstPerson) {
                // First-person camera positioned at bird's head
                const headOffset = new THREE.Vector3(0, 0.5, 0.6); // Position at head
                headOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), -birdPitch); // Apply pitch rotation
                headOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), birdYaw); // Apply yaw rotation

                camera.position.copy(bird.position.clone().add(headOffset));

                // Camera looks in the direction the bird is facing
                const lookDirection = new THREE.Vector3(
                    Math.sin(birdYaw) * Math.cos(birdPitch),
                    Math.sin(birdPitch),
                    Math.cos(birdYaw) * Math.cos(birdPitch)
                );
                const lookTarget = camera.position.clone().add(lookDirection.multiplyScalar(10));
                camera.lookAt(lookTarget);
            } else {
                // Third-person camera follows bird from behind
                const cameraDistance = 10 + currentSpeed * 8;
                // Fixed: camera height now properly responds to pitch direction
                // When pitching up (positive), camera stays level or goes slightly lower
                // When pitching down (negative), camera goes higher to see over the bird
                const cameraHeight = 3 - birdPitch * 8;
                const cameraOffset = new THREE.Vector3(
                    Math.sin(birdYaw) * -cameraDistance,
                    cameraHeight,
                    Math.cos(birdYaw) * -cameraDistance
                );
                camera.position.lerp(bird.position.clone().add(cameraOffset), 0.08);
                camera.lookAt(bird.position);
            }

            // Move clouds slowly for parallax effect
            clouds.forEach((cloud, index) => {
                cloud.position.x += 0.008;
                cloud.position.z += Math.sin(index * 0.5) * 0.002;
                if (cloud.position.x > 150) {
                    cloud.position.x = -150;
                }
            });

            // Update fish behavior
            const CATCH_DISTANCE = 2.0; // Distance to catch a fish

            for (let i = fish.length - 1; i >= 0; i--) {
                const fishObj = fish[i];
                if (fishObj.userData.isCaught) continue;

                // Animate fish swimming
                fishObj.userData.swimTime += 0.05;

                // Calculate distance to bird (3D)
                const dx = bird.position.x - fishObj.position.x;
                const dz = bird.position.z - fishObj.position.z;
                const dy = bird.position.y - fishObj.position.y;
                const distanceToBird = Math.sqrt(dx * dx + dz * dz + dy * dy);

                // Fish swim in wandering patterns underwater
                fishObj.userData.wanderAngle += (Math.random() - 0.5) * 0.1;
                fishObj.userData.verticalAngle += (Math.random() - 0.5) * 0.05;
                fishObj.userData.verticalAngle = Math.max(-0.3, Math.min(0.3, fishObj.userData.verticalAngle));

                // Move fish in 3D space
                const swimSpeed = fishObj.userData.wanderSpeed;
                fishObj.position.x += Math.cos(fishObj.userData.wanderAngle) * swimSpeed;
                fishObj.position.z += Math.sin(fishObj.userData.wanderAngle) * swimSpeed;
                fishObj.position.y += Math.sin(fishObj.userData.verticalAngle) * swimSpeed * 0.5;

                // Keep fish underwater in shallow ocean (between -13 and -2 meters)
                if (fishObj.position.y > -2) {
                    fishObj.position.y = -2;
                    fishObj.userData.verticalAngle = -Math.abs(fishObj.userData.verticalAngle);
                }
                if (fishObj.position.y < -13) {
                    fishObj.position.y = -13;
                    fishObj.userData.verticalAngle = Math.abs(fishObj.userData.verticalAngle);
                }

                // Keep fish within map boundaries
                const fishBoundary = MAP_SIZE - 50;
                if (Math.abs(fishObj.position.x) > fishBoundary) {
                    fishObj.position.x = Math.sign(fishObj.position.x) * fishBoundary;
                    fishObj.userData.wanderAngle = Math.PI - fishObj.userData.wanderAngle;
                }
                if (Math.abs(fishObj.position.z) > fishBoundary) {
                    fishObj.position.z = Math.sign(fishObj.position.z) * fishBoundary;
                    fishObj.userData.wanderAngle = -fishObj.userData.wanderAngle;
                }

                // Update fish rotation to face movement direction
                fishObj.rotation.y = fishObj.userData.wanderAngle;
                fishObj.rotation.x = fishObj.userData.verticalAngle;

                // Animate fish tail and fins
                const tailWag = Math.sin(fishObj.userData.swimTime * 5) * 0.3;
                if (fishObj.children[6]) { // Tail fin
                    fishObj.children[6].rotation.y = tailWag;
                }

                // Check if caught (only when bird is underwater)
                if (distanceToBird < CATCH_DISTANCE && isUnderwater) {
                    fishObj.userData.isCaught = true;
                    scene.remove(fishObj);
                    fish.splice(i, 1);
                    caughtFishCount++;
                }
            }

            // Update shark behavior
            const SHARK_ATTACK_DISTANCE = 3.5; // Distance at which shark attacks
            const SHARK_CHASE_DISTANCE = 20; // Distance at which shark notices bird

            for (let i = 0; i < sharks.length; i++) {
                const shark = sharks[i];

                // Animate shark swimming
                shark.userData.swimTime += 0.03;

                // Calculate distance to bird
                const dx = bird.position.x - shark.position.x;
                const dz = bird.position.z - shark.position.z;
                const dy = bird.position.y - shark.position.y;
                const distanceToBird = Math.sqrt(dx * dx + dz * dz + dy * dy);

                // Shark AI: patrol or chase
                if (isUnderwater && distanceToBird < SHARK_CHASE_DISTANCE) {
                    // Chase the bird!
                    const chaseAngle = Math.atan2(dx, dz);
                    const verticalChase = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));

                    shark.userData.patrolAngle = chaseAngle;
                    shark.userData.verticalAngle = verticalChase;

                    // Sharks swim faster when chasing
                    const chaseSpeed = shark.userData.swimSpeed * 1.3;
                    shark.position.x += Math.sin(chaseAngle) * chaseSpeed;
                    shark.position.z += Math.cos(chaseAngle) * chaseSpeed;
                    shark.position.y += Math.sin(verticalChase) * chaseSpeed * 0.5;
                } else {
                    // Normal patrol behavior
                    shark.userData.patrolAngle += (Math.random() - 0.5) * 0.05;
                    shark.userData.verticalAngle += (Math.random() - 0.5) * 0.02;
                    shark.userData.verticalAngle = Math.max(-0.2, Math.min(0.2, shark.userData.verticalAngle));

                    shark.position.x += Math.sin(shark.userData.patrolAngle) * shark.userData.swimSpeed;
                    shark.position.z += Math.cos(shark.userData.patrolAngle) * shark.userData.swimSpeed;
                    shark.position.y += Math.sin(shark.userData.verticalAngle) * shark.userData.swimSpeed * 0.3;
                }

                // Keep sharks underwater (between -13 and -3 meters)
                if (shark.position.y > -3) {
                    shark.position.y = -3;
                    shark.userData.verticalAngle = -Math.abs(shark.userData.verticalAngle);
                }
                if (shark.position.y < -13) {
                    shark.position.y = -13;
                    shark.userData.verticalAngle = Math.abs(shark.userData.verticalAngle);
                }

                // Keep sharks within map boundaries
                const sharkBoundary = MAP_SIZE - 50;
                if (Math.abs(shark.position.x) > sharkBoundary) {
                    shark.position.x = Math.sign(shark.position.x) * sharkBoundary;
                    shark.userData.patrolAngle = Math.PI - shark.userData.patrolAngle;
                }
                if (Math.abs(shark.position.z) > sharkBoundary) {
                    shark.position.z = Math.sign(shark.position.z) * sharkBoundary;
                    shark.userData.patrolAngle = -shark.userData.patrolAngle;
                }

                // Update shark rotation to face movement direction
                shark.rotation.y = shark.userData.patrolAngle;
                shark.rotation.x = shark.userData.verticalAngle;

                // Animate shark tail
                const tailWag = Math.sin(shark.userData.swimTime * 4) * 0.2;
                if (shark.children[7]) { // Tail fin
                    shark.children[7].rotation.y = tailWag;
                }

                // Check if shark caught the bird (game over)
                if (distanceToBird < SHARK_ATTACK_DISTANCE && isUnderwater) {
                    // Shark attack! Reset bird position and lose some fish
                    bird.position.set(0, 15, 0);
                    birdPitch = 0;
                    birdYaw = 0;
                    oxygen = maxOxygen;

                    // Lose half of caught fish
                    const fishLost = Math.floor(caughtFishCount / 2);
                    caughtFishCount -= fishLost;

                    // Visual feedback - could add alert
                    console.log("Shark attack! Lost " + fishLost + " fish!");
                }
            }

            // Update stats with color coding
            const speedElement = document.getElementById('speed');
            const speedValue = currentSpeed.toFixed(3);
            speedElement.textContent = speedValue;

            // Color code speed
            if (currentSpeed > 0.5) {
                speedElement.className = 'speed-indicator high-speed';
            } else if (currentSpeed < 0.25) {
                speedElement.className = 'speed-indicator low-speed';
            } else {
                speedElement.className = 'speed-indicator';
            }

            document.getElementById('altitude').textContent = Math.round(bird.position.y);
            document.getElementById('pitch').textContent = Math.round(birdPitch * 57.3); // Convert to degrees
            document.getElementById('position').textContent =
                `${Math.round(bird.position.x)}, ${Math.round(bird.position.z)}`;
            document.getElementById('caughtFish').textContent = caughtFishCount;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
